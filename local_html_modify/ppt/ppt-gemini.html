<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huawei Style Smart PPTX Generator Pro</title>
    <!-- 核心依赖 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/gitbrent/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- 图标库 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

    <style>
        /* --- 全局样式变量与重置 --- */
        :root {
            --primary-color: #C8102E;
            /* 华为红标准色 */
            --bg-canvas: #eef2f5;
            --bg-panel: #ffffff;
            --text-main: #333333;
            --border-color: #e0e0e0;
            --sidebar-width: 350px;
            --options-width: 280px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            background: var(--bg-canvas);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- 顶部导航 --- */
        header {
            height: 60px;
            background: #fff;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        .logo-area {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            font-size: 18px;
            color: #000;
        }

        .logo-icon {
            color: var(--primary-color);
            font-size: 24px;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: #a60d26;
            box-shadow: 0 4px 12px rgba(200, 16, 46, 0.3);
        }

        .btn-ghost {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
        }

        .btn-ghost:hover {
            background: #f5f5f5;
        }

        /* --- 主工作区 --- */
        .workspace {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }

        /* 1. 编辑器 (Markdown) */
        .editor-panel {
            width: var(--sidebar-width);
            background: #1e1e1e;
            color: #ccc;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
        }

        .panel-title {
            padding: 12px 16px;
            background: #252526;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }

        textarea.md-input {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
        }

        /* 滚动条美化 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        /* 预览区域滚动条特殊样式 */
        .preview-stage::-webkit-scrollbar {
            width: 10px;
        }

        .preview-stage::-webkit-scrollbar-thumb {
            background: rgba(200, 16, 46, 0.3);
            border-radius: 5px;
        }

        .preview-stage::-webkit-scrollbar-thumb:hover {
            background: rgba(200, 16, 46, 0.5);
        }

        .preview-stage::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        /* 2. 预览舞台 (Canvas) */
        .preview-stage {
            flex: 1;
            background: var(--bg-canvas);
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 40px 0;
        }

        .slides-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            width: 100%;
        }

        .canvas-wrapper {
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            cursor: pointer;
            border: 3px solid transparent;
            position: relative;
        }

        .canvas-wrapper:hover {
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.25);
            transform: scale(1.02);
        }

        .canvas-wrapper.selected {
            border-color: var(--primary-color);
            box-shadow: 0 25px 60px rgba(200, 16, 46, 0.3);
        }

        .canvas-wrapper.selected::after {
            content: '已选中';
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--primary-color);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        /* --- 幻灯片渲染层 (HTML与PPTX逻辑的映射) --- */
        .slide-render {
            width: 960px;
            height: 540px;
            background: white;
            position: relative;
            overflow: hidden;
            /* 禁止用户选择，模拟PPT视图 */
            user-select: none;
        }

        /* 页面序号标签 */
        .slide-number-badge {
            position: absolute;
            top: -15px;
            left: -15px;
            background: var(--primary-color);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 5;
        }

        /* 元素定位基类 */
        .slide-element {
            position: absolute;
            transition: all 0.3s;
        }

        /* 文本框样式 */
        .slide-text {
            word-wrap: break-word;
            color: var(--text-main);
        }

        .slide-text h1 {
            margin: 0 0 0.5em 0;
            line-height: 1.2;
            letter-spacing: -0.5px;
        }

        .slide-text p,
        .slide-text li {
            margin: 0 0 0.6em 0;
            line-height: 1.6;
            color: #555;
        }

        .slide-text ul,
        .slide-text ol {
            padding-left: 1.2em;
            margin: 0;
        }

        .slide-text li::marker {
            color: var(--primary-color);
        }

        /* 引用块样式 */
        .quote-box {
            border-left: 4px solid var(--primary-color);
            padding: 12px 20px;
            background: #f8f9fa;
            color: #444;
            font-style: italic;
            border-radius: 0 4px 4px 0;
        }

        /* 表格样式 (关键新增) */
        .slide-table-wrapper {
            overflow: hidden;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .slide-table {
            width: 100%;
            border-collapse: collapse;
            font-size: inherit;
            border: none;
        }

        .slide-table th {
            background: var(--primary-color);
            color: white;
            padding: 10px 16px;
            text-align: left;
            font-weight: 600;
            border: none;
        }

        .slide-table td {
            padding: 10px 16px;
            border-bottom: 1px solid #eee;
            color: #444;
        }

        .slide-table tr:nth-child(even) {
            background: #fcfcfc;
        }

        .slide-table tr:last-child td {
            border-bottom: none;
        }

        /* 占位图样式 */
        .slide-placeholder {
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #64748b;
            font-size: 14px;
            text-align: center;
            padding: 20px;
            transition: all 0.3s;
        }

        .slide-placeholder:hover {
            border-color: var(--primary-color);
            background: #fff5f5;
        }

        /* 装饰性元素 */
        .theme-decor {
            position: absolute;
            pointer-events: none;
            z-index: 0;
        }

        /* 卡片样式 (Grid Layout) */
        .grid-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            border: 1px solid #eee;
            display: flex;
            flex-direction: column;
        }

        .grid-card-header {
            height: 6px;
            background: var(--primary-color);
        }

        .grid-card-body {
            padding: 16px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }


        /* 3. 右侧选项栏 */
        .options-panel {
            width: var(--options-width);
            background: #fff;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .layout-card {
            margin: 16px;
            border: 2px solid transparent;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .layout-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .layout-card.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(200, 16, 46, 0.1);
        }

        .layout-thumb {
            height: 100px;
            background: #f0f0f0;
            position: relative;
            overflow: hidden;
        }

        .layout-info {
            padding: 10px;
            background: #fafafa;
        }

        .layout-name {
            font-weight: 600;
            font-size: 13px;
            color: #333;
            margin-bottom: 4px;
        }

        .layout-desc {
            font-size: 11px;
            color: #888;
        }

        .badge {
            position: absolute;
            top: 6px;
            right: 6px;
            background: var(--primary-color);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* 底部控制条 */
        .zoom-ctrl {
            position: fixed;
            bottom: 20px;
            right: 320px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            gap: 12px;
            backdrop-filter: blur(4px);
            z-index: 100;
        }

        .zoom-ctrl i {
            cursor: pointer;
        }

        .zoom-ctrl i:hover {
            color: #fff;
        }
    </style>
</head>

<body>

    <div id="app">
        <!-- 1. Header -->
        <header>
            <div class="logo-area">
                <i class="fas fa-shapes logo-icon"></i>
                <span>Huawei SmartSlide Pro</span>
            </div>
            <div class="header-actions">
                <div style="font-size: 13px; color: #666; margin-right: 10px;">
                    当前页: <b>{{ currentPageIndex + 1 }}</b> / {{ slides.length }}
                </div>
                <button class="btn btn-ghost" @click="resetContent">
                    <i class="fas fa-rotate-left"></i> 重置
                </button>
                <button class="btn btn-ghost" @click="triggerImport">
                    <i class="fas fa-file-import"></i> 导入模板
                </button>
                <input type="file" ref="fileInput" accept=".pptx" style="display: none" @change="handleFileImport">
                <button class="btn btn-primary" @click="exportPPTX">
                    <i class="fas fa-file-powerpoint"></i> 导出 PPTX
                </button>
            </div>
        </header>

        <div class="workspace">
            <!-- 2. Markdown Editor -->
            <div class="editor-panel">
                <div class="panel-title">
                    <span>Markdown Input</span>
                    <i class="fab fa-markdown"></i>
                </div>
                <textarea class="md-input" v-model="markdownInput" @input="handleInput"
                    placeholder="在此输入 Markdown... 使用 '---' 分页"></textarea>
            </div>

            <!-- 3. Preview Stage -->
            <div class="preview-stage" @wheel.ctrl.prevent="handleWheel">
                <div class="slides-container" :style="{ transform: `scale(${previewScale})` }">

                    <!-- 遍历所有幻灯片 -->
                    <div v-for="(slide, slideIdx) in slides" :key="slideIdx" class="canvas-wrapper"
                        :class="{ selected: currentPageIndex === slideIdx }" @click="selectSlide(slideIdx)">

                        <!-- 页面序号徽章 -->
                        <div class="slide-number-badge">{{ slideIdx + 1 }}</div>

                        <!-- 核心渲染组件：这里即是"所见"，也是导出逻辑的直接映射 -->
                        <div class="slide-render">

                            <!-- 背景装饰 (SVG 或 图片) -->
                            <div class="theme-decor" style="top:0; left:0; width:100%; height:100%"
                                v-html="getSlideBackground(getSlideResult(slide).master)">
                            </div>

                            <!-- 动态元素渲染 -->
                            <div v-for="(el, idx) in getSlideResult(slide).elements" :key="idx"
                                :class="['slide-element', getElementClass(el.type)]" :style="getElementStyle(el)">

                                <!-- 文本类型 -->
                                <div v-if="el.type === 'text'" v-html="el.html"></div>

                                <!-- 表格类型 (新增) -->
                                <div v-else-if="el.type === 'table'" class="slide-table-wrapper">
                                    <table class="slide-table">
                                        <thead>
                                            <tr>
                                                <th v-for="h in el.data.header">{{ h }}</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr v-for="row in el.data.rows">
                                                <td v-for="cell in row">{{ cell }}</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>

                                <!-- 占位图类型 -->
                                <div v-else-if="el.type === 'placeholder'" class="slide-placeholder">
                                    <i class="fas fa-image fa-2x" style="margin-bottom:8px; opacity:0.5"></i>
                                    <div>{{ el.alt }}</div>
                                </div>

                                <!-- 形状类型 -->
                                <div v-else-if="el.type === 'shape'"
                                    :style="{width: '100%', height:'100%', background: el.fill}"></div>
                            </div>

                            <!-- 页码 -->
                            <div style="position:absolute; bottom:15px; right:20px; color:#999; font-size:12px;">
                                {{ slideIdx + 1 }}
                            </div>
                        </div>

                    </div>

                </div>

                <div class="zoom-ctrl">
                    <i class="fas fa-minus" @click="previewScale -= 0.1"></i>
                    <span>{{ Math.round(previewScale * 100) }}%</span>
                    <i class="fas fa-plus" @click="previewScale += 0.1"></i>
                </div>
            </div>

            <!-- 4. Layout Options -->
            <div class="options-panel">
                <div class="panel-title">智能排版方案</div>
                <div v-for="(layout, key) in currentLayouts" :key="key" class="layout-card"
                    :class="{ active: currentSlide?.selectedLayout === key }" @click="selectLayout(key)">

                    <!-- 迷你缩略图 (用CSS缩放模拟) -->
                    <div class="layout-thumb">
                        <div
                            style="transform: scale(0.2); transform-origin: top left; width: 960px; height: 540px; background: white; padding:20px;">
                            <!-- 简单示意红线 -->
                            <div style="height:10px; background:#C8102E; width:100%; margin-bottom:20px"></div>
                            <!-- 简单示意内容块 -->
                            <div v-for="el in layout.elements"
                                :style="{position:'absolute', left:el.x+'px', top:el.y+'px', width:el.w+'px', height: (el.h||20)+'px', background:'#ddd', opacity:0.5}">
                            </div>
                        </div>
                        <span v-if="layout.isRecommended" class="badge">推荐</span>
                    </div>

                    <div class="layout-info">
                        <div class="layout-name">方案 {{ key }}</div>
                        <div class="layout-desc">{{ layout.desc }}</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        const THEME_CONFIG = {
            colors: {
                primary: '#C8102E',
                text: '#333333',
                secondaryText: '#666666',
                accentBg: '#f9f9f9'
            },
            canvas: { w: 960, h: 540 },
            margins: { top: 70, bottom: 40, left: 50, right: 50 },
            decorSvg: {
                normal: `
                    <svg width="100%" height="100%" viewBox="0 0 960 540" preserveAspectRatio="none">
                        <rect x="0" y="0" width="960" height="6" fill="#C8102E" />
                        <rect x="900" y="500" width="40" height="20" rx="2" fill="#ddd" opacity="0.5" />
                        <text x="920" y="514" font-size="10" fill="#999" text-anchor="middle" font-family="Arial">LOGO</text>
                    </svg>
                `,
                cover: `
                    <svg width="100%" height="100%" viewBox="0 0 960 540" preserveAspectRatio="none">
                        <path d="M0 0 H380 L320 540 H0 V0 Z" fill="#C8102E" />
                        <path d="M380 0 L400 0 L340 540 L320 540 Z" fill="#C8102E" opacity="0.1" />
                    </svg>
                `
            }
        };

        class LayoutEngine {
            constructor() {
                this.C = THEME_CONFIG.canvas;
                this.M = THEME_CONFIG.margins;
            }

            generateLayouts(slideData) {
                const stats = this.analyzeContent(slideData);
                const layouts = {};
                const isCoverPage = slideData.subtitle && slideData.blocks.length === 0;

                if (isCoverPage) {
                    layouts['A'] = this.layoutCover(slideData);
                    layouts['A'].isRecommended = true;
                    return { layouts, best: 'A' };
                }

                layouts['A'] = this.layoutStandard(slideData, stats);
                layouts['B'] = this.layoutSplit(slideData, stats);
                layouts['C'] = this.layoutGrid(slideData, stats);

                let best = 'A';
                if (stats.hasTable) best = 'A';
                else if (stats.hasImage && stats.charCount > 50) best = 'B';
                else if (stats.listItems >= 4 || stats.imgCount >= 2) best = 'C';
                else if (stats.charCount > 500) best = 'A';

                layouts[best].isRecommended = true;

                return { layouts, best };
            }

            layoutCover(data) {
                const elements = [];

                elements.push({
                    type: 'text',
                    html: `<h1 style="font-size:56px; color:#fff; margin:0; line-height:1.1; font-weight:800">${data.title}</h1>`,
                    text: data.title,
                    x: 40,
                    y: 180,
                    w: 300,
                    h: 200,
                    fontSize: 56,
                    bold: true,
                    color: 'FFFFFF',
                    align: 'left'
                });

                if (data.subtitle) {
                    elements.push({
                        type: 'text',
                        html: `<div style="font-size:24px; color:#666; margin:0; border-left:4px solid #C8102E; padding-left:20px">${data.subtitle}</div>`,
                        text: data.subtitle,
                        x: 420,
                        y: 200,
                        w: 480,
                        h: 100,
                        fontSize: 24,
                        color: '666666',
                        align: 'left'
                    });
                }

                elements.push({
                    type: 'text',
                    html: `<div style="font-size:14px; color:rgba(255,255,255,0.6); font-family:Arial">2025 REPORT</div>`,
                    text: '2025 REPORT',
                    x: 40,
                    y: 500,
                    w: 200,
                    h: 20,
                    fontSize: 12,
                    color: 'FFCCCC'
                });

                return { elements, desc: '现代分割封面', master: 'cover' };
            }

            analyzeContent(data) {
                let charCount = 0;
                let listItems = 0;
                let hasTable = false;
                let hasImage = false;
                let imgCount = 0;

                data.blocks.forEach(b => {
                    if (b.type === 'text') charCount += b.content.length;
                    if (b.type === 'list') listItems += b.items.length;
                    if (b.type === 'table') hasTable = true;
                    if (b.type === 'image') {
                        hasImage = true;
                        imgCount += 1;
                    }
                });

                return { charCount, listItems, hasTable, hasImage, imgCount };
            }

            layoutStandard(data, stats) {
                const elements = [];
                let currY = this.M.top;
                const contentW = this.C.w - this.M.left - this.M.right;

                elements.push(this.createTitle(data.title, this.M.left, 40, contentW));
                currY += 50;

                const blocks = data.blocks;
                const fontSize = stats.charCount > 400 ? 14 : 18;

                if (blocks.length === 1 && blocks[0].type === 'table') {
                    elements.push({
                        type: 'table',
                        data: blocks[0].data,
                        x: this.M.left,
                        y: currY + 20,
                        w: contentW,
                        h: 300
                    });
                    return { elements, desc: '表格/标准布局', master: 'normal' };
                }

                const useTwoCol = stats.charCount > 350 && !stats.hasTable;
                let leftColY = currY;
                let rightColY = currY;
                const colW = useTwoCol ? (contentW - 40) / 2 : contentW;

                blocks.forEach((b, i) => {
                    const isRight = useTwoCol && i >= blocks.length / 2;
                    const x = isRight ? (this.M.left + colW + 40) : this.M.left;
                    let y = isRight ? rightColY : leftColY;

                    const h = this.estimateBlockHeight(b, colW, fontSize);
                    const el = this.blockToElement(b, x, y, colW, h, fontSize);
                    elements.push(el);

                    if (isRight) rightColY += h + 20;
                    else leftColY += h + 20;
                });

                return { elements, desc: useTwoCol ? '双栏密集型' : '标准通栏', master: 'normal' };
            }

            layoutSplit(data, stats) {
                const elements = [];
                elements.push(this.createTitle(data.title, this.M.left, 40, this.C.w - 100));

                const leftW = (this.C.w - this.M.left - this.M.right - 40) * 0.5;
                const rightX = this.M.left + leftW + 40;
                let currLeftY = 100;
                let currRightY = 100;

                data.blocks.forEach(b => {
                    if (b.type === 'image') {
                        elements.push(this.blockToElement(b, rightX, currRightY, leftW, 350, 14));
                        currRightY += 370;
                    } else {
                        const h = this.estimateBlockHeight(b, leftW, 16);
                        elements.push(this.blockToElement(b, this.M.left, currLeftY, leftW, h, 16));
                        currLeftY += h + 20;
                    }
                });

                return { elements, desc: '图文分栏布局', master: 'normal' };
            }

            layoutGrid(data) {
                const elements = [];
                elements.push(this.createTitle(data.title, this.M.left, 40, this.C.w - 100));

                const items = [];
                data.blocks.forEach(b => {
                    if (b.type === 'list') {
                        b.items.forEach(item => items.push({ type: 'text', content: item }));
                    } else if (b.type === 'image') {
                        items.push({ type: 'img', ...b });
                    } else {
                        items.push({ type: 'text', content: b.content || '...' });
                    }
                });

                const count = items.length;
                let cols = 3;
                if (count === 1) cols = 1;
                else if (count === 2 || count === 4) cols = 2;

                const displayItems = items.slice(0, 6);
                const startY = 110;
                const gap = 20;
                const totalW = this.C.w - this.M.left - this.M.right;
                const cardW = (totalW - (cols - 1) * gap) / cols;
                const cardH = count <= 3 ? 200 : 150;

                displayItems.forEach((item, i) => {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = this.M.left + col * (cardW + gap);
                    const y = startY + row * (cardH + gap);

                    elements.push({ type: 'shape', fill: '#ffffff', x, y, w: cardW, h: cardH, border: '#e0e0e0' });
                    elements.push({ type: 'shape', fill: THEME_CONFIG.colors.primary, x, y, w: cardW, h: 4 });

                    if (item.type === 'img') {
                        elements.push({ type: 'placeholder', alt: item.alt, x: x + 15, y: y + 20, w: cardW - 30, h: cardH - 35 });
                    } else {
                        elements.push({
                            type: 'text',
                            html: `<div style="font-size:16px; color:#333; font-weight:500">${item.content}</div>`,
                            text: item.content,
                            x: x + 20,
                            y: y + 25,
                            w: cardW - 40,
                            h: cardH - 50,
                            fontSize: 16,
                            align: 'left',
                            valign: 'top'
                        });
                    }
                });

                return { elements, desc: `智能网格 (${cols}列)`, master: 'normal' };
            }

            createTitle(text, x, y, w) {
                return {
                    type: 'text',
                    html: `<h1 style="font-size:32px; color:#000; margin:0">${text}</h1>`,
                    text,
                    x,
                    y,
                    w,
                    h: 50,
                    fontSize: 32,
                    bold: true
                };
            }

            blockToElement(b, x, y, w, h, fontSize) {
                if (b.type === 'image') {
                    return { type: 'placeholder', alt: b.alt, x, y, w, h: h || 200 };
                }
                if (b.type === 'table') {
                    return { type: 'table', data: b.data, x, y, w, h: h || 200 };
                }

                let htmlContent = b.content || '';
                let textContent = b.content || '';

                if (b.type === 'list') {
                    htmlContent = '<ul style="margin:0; padding-left:1.5em; line-height:1.6">' +
                        b.items.map(i => {
                            const processed = i.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                            return `<li style="margin-bottom:0.4em">${processed}</li>`;
                        }).join('') + '</ul>';
                    textContent = b.items.join('\n');
                } else if (b.type === 'quote') {
                    htmlContent = `<div class="quote-box">${b.content}</div>`;
                } else if (textContent) {
                    htmlContent = htmlContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                }

                return {
                    type: 'text',
                    html: `<div style="font-size:${fontSize || 16}px; line-height:1.5">${htmlContent}</div>`,
                    text: textContent,
                    rawBlock: b,
                    x,
                    y,
                    w,
                    h,
                    fontSize: fontSize || 16
                };
            }

            estimateBlockHeight(b, w, fontSize) {
                if (b.type === 'image') return 220;
                if (b.type === 'table') return (b.data.rows.length + 1) * 35 + 20;

                const charsPerLine = w / (fontSize * 0.55);
                let lines = 0;

                if (b.type === 'list') {
                    b.items.forEach(i => {
                        const itemLines = Math.max(1, Math.ceil(i.length / charsPerLine));
                        lines += itemLines;
                    });
                    return Math.max(lines * (fontSize * 1.6) + b.items.length * 4, 50);
                }

                if (b.type === 'quote') {
                    lines = Math.ceil((b.content || '').length / charsPerLine);
                    return Math.max(lines * (fontSize * 1.6) + 20, 60);
                }

                lines = Math.ceil((b.content || '').length / charsPerLine);
                return Math.max(lines * (fontSize * 1.5), 40);
            }
        }

        const DEFAULT_MD = `# 2025 季度汇报
核心业务数据分析

---
## 市场增长趋势
> 过去三个季度，企业级市场保持了 **25%** 的高速增长。

* AI 算力需求激增，带动基础设施建设。
* SaaS 订阅收入占比提升至 40%。
* 客户满意度评分 (NPS) 达到历史新高。

![增长曲线](Placeholder)

---
## 核心数据对比 (自动渲染表格)

| 部门 | Q1 营收 (M) | Q2 营收 (M) | 增长率 |
| :--- | :--- | :--- | :--- |
| 云服务 | 120 | 145 | +21% |
| 终端设备 | 300 | 310 | +3.3% |
| 智能汽车 | 50 | 90 | +80% |

此表格将自动解析并适配 PPT 样式。

---
## 战略举措 - 矩阵排版
* **研发投入**: 持续加大基础科学研究。
* **生态建设**: 赋能开发者，共建开放生态。
* **全球化**: 本地化运营，服务全球客户。
* **人才梯队**: 启动天才少年计划 3.0。
* **合规经营**: 严格遵守各地法律法规。
* **绿色低碳**: 践行碳中和承诺。
`;

        // --- PPTX 解析工具类 ---
        class PPTXLoader {
            constructor() {
                this.zip = null;
                this.slideMasters = {};
                this.themeColors = {};
            }

            async load(file) {
                try {
                    this.zip = await JSZip.loadAsync(file);
                    await this.parseSlideMasters();
                    return this.slideMasters;
                } catch (e) {
                    console.error('PPTX Parsing Error:', e);
                    alert('解析 PPTX 模板失败，请确保文件格式正确。');
                    return null;
                }
            }

            async parseSlideMasters() {
                // 1. 读取 Content_Types 找到 slideMaster
                const contentTypesXml = await this.zip.file('[Content_Types].xml').async('text');
                const parser = new DOMParser();
                const contentTypesDoc = parser.parseFromString(contentTypesXml, 'text/xml');

                // 简单起见，我们假设 slideMaster1 是主母版 (通常如此)
                // 实际应该解析 rels，但这里做简化处理
                const masterFile = this.zip.file('ppt/slideMasters/slideMaster1.xml');
                if (!masterFile) return;

                const masterXml = await masterFile.async('text');
                const masterDoc = parser.parseFromString(masterXml, 'text/xml');

                // 2. 提取背景
                const bg = await this.extractBackground(masterDoc);

                // 3. 提取标题样式 (颜色)
                const titleStyle = this.extractTextStyle(masterDoc, 'titleStyle');
                const bodyStyle = this.extractTextStyle(masterDoc, 'bodyStyle');

                this.slideMasters = {
                    normal: { background: bg, titleStyle, bodyStyle },
                    cover: { background: bg, titleStyle, bodyStyle } // 暂时复用
                };
            }

            async extractBackground(doc) {
                const bgPr = doc.getElementsByTagName('p:bgPr')[0];
                if (!bgPr) return null;

                // 检查是否是图片填充
                const blipFill = bgPr.getElementsByTagName('a:blipFill')[0];
                if (blipFill) {
                    const blip = blipFill.getElementsByTagName('a:blip')[0];
                    const embedId = blip.getAttribute('r:embed');
                    if (embedId) {
                        return await this.getImageByRelId('ppt/slideMasters/_rels/slideMaster1.xml.rels', embedId);
                    }
                }

                // 检查纯色填充
                const solidFill = bgPr.getElementsByTagName('a:solidFill')[0];
                if (solidFill) {
                    return this.getColorFromNode(solidFill);
                }

                return null;
            }

            async getImageByRelId(relsPath, relId) {
                const relsFile = this.zip.file(relsPath);
                if (!relsFile) return null;

                const relsXml = await relsFile.async('text');
                const parser = new DOMParser();
                const relsDoc = parser.parseFromString(relsXml, 'text/xml');

                const relNode = relsDoc.querySelector(`Relationship[Id="${relId}"]`);
                if (!relNode) return null;

                let target = relNode.getAttribute('Target');
                // Target 可能是 "../media/image1.png" 或 "media/image1.png"
                target = target.replace('../', 'ppt/');
                if (!target.startsWith('ppt/')) target = 'ppt/' + target;

                const imgFile = this.zip.file(target);
                if (imgFile) {
                    const base64 = await imgFile.async('base64');
                    const ext = target.split('.').pop();
                    return `data:image/${ext};base64,${base64}`;
                }
                return null;
            }

            extractTextStyle(doc, styleName) {
                const styleNode = doc.getElementsByTagName(`p:${styleName}`)[0];
                if (!styleNode) return null;

                // 获取第一层级 (lvl1pPr) 的样式
                const lvl1 = styleNode.getElementsByTagName('a:lvl1pPr')[0];
                if (!lvl1) return null;

                const defRPr = lvl1.getElementsByTagName('a:defRPr')[0];
                if (defRPr) {
                    const solidFill = defRPr.getElementsByTagName('a:solidFill')[0];
                    if (solidFill) {
                        return { color: this.getColorFromNode(solidFill) };
                    }
                }
                return null;
            }

            getColorFromNode(node) {
                const srgbClr = node.getElementsByTagName('a:srgbClr')[0];
                if (srgbClr) {
                    return '#' + srgbClr.getAttribute('val');
                }
                const schemeClr = node.getElementsByTagName('a:schemeClr')[0];
                if (schemeClr) {
                    // 简化：如果是主题色，暂时返回黑色或特定色，因为解析主题色表太复杂
                    const val = schemeClr.getAttribute('val');
                    if (val === 'tx1') return '#000000';
                    if (val === 'bg1') return '#FFFFFF';
                    if (val === 'accent1') return '#C8102E'; // 默认华为红
                    return '#666666';
                }
                return null;
            }
        }

        createApp({
            setup() {
                const markdownInput = ref(DEFAULT_MD);
                const slides = ref([]);
                const currentPageIndex = ref(0);
                const previewScale = ref(0.8);
                const engine = new LayoutEngine();
                const slideStates = ref({});
                const fileInput = ref(null);
                const customTheme = ref(null); // 存储导入的模板样式
                let inputTimer;

                const processMarkdown = () => {
                    const rawSlides = markdownInput.value.split(/^---$/m);
                    slides.value = rawSlides.map((raw, idx) => {
                        const tokens = marked.lexer(raw);
                        const slideData = { title: '未命名幻灯片', subtitle: '', blocks: [] };
                        let foundTitle = false;

                        tokens.forEach(t => {
                            if (t.type === 'heading' && t.depth <= 2 && !foundTitle) {
                                slideData.title = t.text;
                                foundTitle = true;
                            } else if (t.type === 'paragraph') {
                                const img = t.text.match(/!\[(.*?)\]\((.*?)\)/);
                                if (img) {
                                    slideData.blocks.push({ type: 'image', alt: img[1] });
                                } else if (t.text.trim()) {
                                    if (foundTitle && slideData.blocks.length === 0 && !slideData.subtitle) {
                                        slideData.subtitle = t.text.trim();
                                    } else {
                                        slideData.blocks.push({ type: 'text', content: t.text });
                                    }
                                }
                            } else if (t.type === 'list') {
                                slideData.blocks.push({ type: 'list', items: t.items.map(i => i.text) });
                            } else if (t.type === 'blockquote') {
                                slideData.blocks.push({ type: 'quote', content: t.text });
                            } else if (t.type === 'table') {
                                slideData.blocks.push({
                                    type: 'table',
                                    data: {
                                        header: t.header.map(h => h.text),
                                        rows: t.rows.map(row => row.map(cell => cell.text))
                                    }
                                });
                            }
                        });

                        const { layouts, best } = engine.generateLayouts(slideData);
                        const savedState = slideStates.value[idx];
                        const selectedLayout = savedState ? savedState.selectedLayout : best;
                        slideStates.value[idx] = { selectedLayout };

                        return { data: slideData, layouts, selectedLayout };
                    });

                    if (slides.value.length === 0) {
                        currentPageIndex.value = 0;
                    } else if (currentPageIndex.value >= slides.value.length) {
                        currentPageIndex.value = slides.value.length - 1;
                    }
                };

                const handleInput = () => {
                    clearTimeout(inputTimer);
                    inputTimer = setTimeout(processMarkdown, 500);
                };

                const currentSlide = computed(() => slides.value[currentPageIndex.value]);
                const currentLayouts = computed(() => currentSlide.value?.layouts || {});
                const currentSlideResult = computed(() => {
                    if (!currentSlide.value) return null;
                    return currentSlide.value.layouts[currentSlide.value.selectedLayout];
                });

                const getSlideResult = slide => {
                    if (!slide) return { elements: [], master: 'normal' };
                    return slide.layouts[slide.selectedLayout];
                };

                const selectSlide = index => {
                    currentPageIndex.value = index;
                };

                const selectLayout = key => {
                    if (currentSlide.value) {
                        currentSlide.value.selectedLayout = key;
                        slideStates.value[currentPageIndex.value].selectedLayout = key;
                    }
                };

                const getElementClass = type => (type === 'text' ? 'slide-text' : '');
                const getElementStyle = el => {
                    const style = {
                        left: `${el.x}px`,
                        top: `${el.y}px`,
                        width: `${el.w}px`
                    };
                    if (el.h != null) style.height = `${el.h}px`;
                    if (el.fontSize) style.fontSize = `${el.fontSize}px`;
                    if (el.color) style.color = el.color.startsWith('#') ? el.color : `#${el.color}`;
                    if (el.align) style.textAlign = el.align;

                    // 应用自定义模板的字体颜色
                    if (customTheme.value && customTheme.value.normal && customTheme.value.normal.bodyStyle) {
                        // 简单覆盖：如果元素没有显式指定颜色（通常标题有，正文没有），则使用模板色
                        // 这里需要更精细的判断，暂时只对普通文本生效
                        if (!el.bold && el.type === 'text') { // 假设非粗体为正文
                            const customColor = customTheme.value.normal.bodyStyle.color;
                            if (customColor) style.color = customColor;
                        }
                    }

                    return style;
                };

                const resetContent = () => {
                    if (confirm('确定恢复默认内容吗？')) {
                        markdownInput.value = DEFAULT_MD;
                        customTheme.value = null; // 重置模板
                        processMarkdown();
                    }
                };

                const handleWheel = e => {
                    if (e.ctrlKey) {
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        previewScale.value = Math.min(Math.max(0.3, previewScale.value + delta), 2.0);
                    }
                };

                // --- 导入相关逻辑 ---
                const triggerImport = () => {
                    fileInput.value.click();
                };

                const handleFileImport = async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const loader = new PPTXLoader();
                    const masters = await loader.load(file);

                    if (masters) {
                        customTheme.value = masters;
                        alert('模板导入成功！背景和基础样式已更新。');
                    }

                    // 清空 input 以便重复选择同一文件
                    event.target.value = '';
                };

                // 获取当前背景样式
                const getSlideBackground = (layoutMaster) => {
                    if (customTheme.value) {
                        const master = customTheme.value[layoutMaster] || customTheme.value.normal;
                        if (master && master.background) {
                            if (master.background.startsWith('data:image')) {
                                return `<div style="position:absolute; top:0; left:0; width:100%; height:100%; background-image: url('${master.background}'); background-size: cover; background-position: center;"></div>`;
                            } else {
                                return `<div style="position:absolute; top:0; left:0; width:100%; height:100%; background-color: ${master.background};"></div>`;
                            }
                        }
                    }
                    // 默认背景
                    return THEME_CONFIG.decorSvg[layoutMaster || 'normal'];
                };


                const exportPPTX = () => {
                    if (!slides.value.length) {
                        alert('没有幻灯片可导出');
                        return;
                    }

                    const pptx = new PptxGenJS();
                    pptx.layout = 'LAYOUT_16x9';

                    // 定义母版
                    if (customTheme.value) {
                        // 使用自定义模板
                        const defineCustomMaster = (name, masterData) => {
                            const bgObj = {};
                            if (masterData.background) {
                                if (masterData.background.startsWith('data:image')) {
                                    bgObj.data = masterData.background; // PPTXGenJS 支持 data:image
                                } else {
                                    bgObj.color = masterData.background.replace('#', '');
                                }
                            } else {
                                bgObj.color = 'FFFFFF';
                            }

                            pptx.defineSlideMaster({
                                title: name,
                                background: bgObj,
                                objects: [] // 既然有了背景图，就不需要额外的 rect 装饰了
                            });
                        };

                        defineCustomMaster('MASTER_NORMAL', customTheme.value.normal);
                        defineCustomMaster('MASTER_COVER', customTheme.value.cover || customTheme.value.normal);

                    } else {
                        // 默认母版
                        pptx.defineSlideMaster({
                            title: 'MASTER_NORMAL',
                            background: { color: 'FFFFFF' },
                            objects: [
                                { rect: { x: 0, y: 0, w: 10, h: 0.06, fill: { color: 'C8102E' } } },
                                { rect: { x: 9.4, y: 5.2, w: 0.4, h: 0.2, fill: { color: 'EEEEEE' } } },
                                { text: { text: 'LOGO', options: { x: 9.4, y: 5.2, w: 0.4, h: 0.2, align: 'center', fontSize: 8, color: '999999' } } }
                            ],
                            slideNumber: { x: 0.3, y: 5.3, color: '999999', fontSize: 10 }
                        });

                        pptx.defineSlideMaster({
                            title: 'MASTER_COVER',
                            background: { color: 'FFFFFF' },
                            objects: [
                                { rect: { x: 0, y: 0, w: 4, h: 5.625, fill: { color: 'C8102E' } } },
                                { rect: { x: 4, y: 0, w: 0.1, h: 5.625, fill: { color: 'C8102E', transparency: 90 } } }
                            ]
                        });
                    }

                    const pxToInch = value => (value * 10) / 960;
                    const masterMap = { cover: 'MASTER_COVER', normal: 'MASTER_NORMAL' };

                    slides.value.forEach(slide => {
                        const layout = slide.layouts[slide.selectedLayout];
                        const pptSlide = pptx.addSlide({ masterName: masterMap[layout.master] || 'MASTER_NORMAL' });

                        layout.elements.forEach(el => {
                            const props = {
                                x: pxToInch(el.x),
                                y: pxToInch(el.y),
                                w: pxToInch(el.w)
                            };
                            if (el.h != null) props.h = pxToInch(el.h);

                            // 颜色处理：如果有自定义模板且元素未显式指定颜色，尝试使用模板色
                            let textColor = el.color ? el.color.replace('#', '') : '333333';
                            if (customTheme.value && !el.color) {
                                // 简单逻辑：正文用 bodyStyle 颜色
                                if (el.type === 'text' && !el.bold && customTheme.value.normal.bodyStyle) {
                                    textColor = customTheme.value.normal.bodyStyle.color.replace('#', '');
                                }
                            }

                            const fontSize = (el.fontSize || 14) * 0.75;

                            if (el.type === 'text') {
                                const textProps = { ...props, color: textColor, fontSize, valign: 'top' };
                                if (el.align) textProps.align = el.align;
                                if (el.bold) textProps.bold = true;

                                if (el.rawBlock && el.rawBlock.type === 'quote') {
                                    pptSlide.addShape(pptx.ShapeType.rect, {
                                        x: props.x,
                                        y: props.y,
                                        w: 0.05,
                                        h: props.h || 1,
                                        fill: { color: 'C8102E' }
                                    });
                                    const quoteX = (textProps.x || 0) + 0.2;
                                    const quoteW = (textProps.w || 0) - 0.2;
                                    pptSlide.addShape(pptx.ShapeType.rect, {
                                        x: quoteX - 0.1,
                                        y: props.y,
                                        w: quoteW + 0.1,
                                        h: props.h || 1,
                                        fill: { color: 'F9F9F9' }
                                    });
                                    textProps.x = quoteX;
                                    textProps.w = quoteW;
                                }

                                if (el.rawBlock && el.rawBlock.type === 'list') {
                                    el.rawBlock.items.forEach((item, idx) => {
                                        const segments = [];
                                        const boldRegex = /\*\*(.*?)\*\*/g;
                                        let lastIndex = 0;
                                        let match;
                                        while ((match = boldRegex.exec(item)) !== null) {
                                            if (match.index > lastIndex) {
                                                segments.push({ text: item.substring(lastIndex, match.index), options: {} });
                                            }
                                            segments.push({ text: match[1], options: { bold: true } });
                                            lastIndex = boldRegex.lastIndex;
                                        }
                                        if (lastIndex < item.length) {
                                            segments.push({ text: item.substring(lastIndex), options: {} });
                                        }

                                        pptSlide.addText(segments.length ? segments : item, {
                                            ...textProps,
                                            y: textProps.y + idx * 0.4,
                                            h: 0.4,
                                            bullet: true
                                        });
                                    });
                                } else {
                                    pptSlide.addText(el.text, textProps);
                                }
                            } else if (el.type === 'table') {
                                const rows = [el.data.header, ...el.data.rows];
                                const colCount = el.data.header.length;
                                pptSlide.addTable(rows, {
                                    x: props.x,
                                    y: props.y,
                                    w: props.w,
                                    border: { pt: 1, color: 'DDDDDD' },
                                    fill: { color: 'FFFFFF' },
                                    color: '333333',
                                    fontSize: 11,
                                    fontFace: 'Arial',
                                    valign: 'middle',
                                    rowH: [0.45, ...el.data.rows.map(() => 0.4)],
                                    colW: Array(colCount).fill(props.w / colCount),
                                    autoPage: false,
                                    rowOpts: [
                                        { fill: { color: 'C8102E' }, color: 'FFFFFF', bold: true, fontSize: 11 }
                                    ]
                                });
                            } else if (el.type === 'placeholder') {
                                pptSlide.addText(`[图: ${el.alt}]`, { ...props, fill: { color: 'F4F6F8' }, align: 'center' });
                            } else if (el.type === 'shape') {
                                pptSlide.addShape(pptx.ShapeType.rect, { ...props, fill: { color: el.fill ? el.fill.replace('#', '') : 'FFFFFF' } });
                            }
                        });
                    });

                    pptx.writeFile({ fileName: `Huawei-SmartSlide-Master-${new Date().toISOString().slice(0, 10)}.pptx` });
                };

                onMounted(() => {
                    processMarkdown();
                });

                return {
                    markdownInput,
                    slides,
                    currentPageIndex,
                    previewScale,
                    currentSlide,
                    currentLayouts,
                    currentSlideResult,
                    themeConfig: THEME_CONFIG,
                    handleInput,
                    selectLayout,
                    selectSlide,
                    getSlideResult,
                    getElementClass,
                    getElementStyle,
                    exportPPTX,
                    resetContent,
                    handleWheel,
                    triggerImport,
                    handleFileImport,
                    fileInput,
                    getSlideBackground
                };
            }
        }).mount('#app');
    </script>


</body>

</html>