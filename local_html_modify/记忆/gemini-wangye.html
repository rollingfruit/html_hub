<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®°å¿†å®«æ®¿ - SRSæ™ºèƒ½å¤ä¹ ç³»ç»Ÿ</title>
    <style>
        :root {
            --accent: #3b82f6;
            --text: #1e293b;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #000;
            touch-action: none;
        }

        /* HUD å±‚ */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }

        /* ä»Šæ—¥è¿›åº¦æ¡ */
        #progress-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .progress-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .progress-num {
            font-weight: bold;
            color: var(--warning);
        }

        /* å‡†å¿ƒ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(0, 0, 0, 0.5);
            transition: all 0.2s;
        }

        /* é¡¶éƒ¨æç¤ºæ¡ */
        #holding-bar {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            padding: 15px 30px;
            border-radius: 30px;
            display: none;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--accent);
        }

        #holding-word {
            font-size: 24px;
            font-weight: bold;
            display: block;
        }

        #holding-hint {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        /* åº•éƒ¨æ“ä½œæ  */
        #action-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }

        .action-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 500;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .action-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .action-btn.success {
            background: var(--success);
            border-color: var(--success);
        }

        .action-btn.warning {
            background: var(--warning);
            border-color: var(--warning);
        }

        /* é€šç”¨å¼¹çª—æ ·å¼ */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 16px;
            width: 400px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            pointer-events: auto;
            z-index: 100;
        }

        .modal h3 {
            margin: 0 0 15px 0;
            color: var(--text);
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-sizing: border-box;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        /* è¯¦æƒ…å¡ç‰‡å¼¹çª— - SRSæ ·å¼ */
        #detail-card {
            text-align: center;
            width: 380px;
            border: 4px solid #333;
        }

        #detail-word {
            font-size: 42px;
            font-weight: 800;
            margin: 0;
            color: #000;
        }

        #detail-mean {
            font-size: 20px;
            color: #555;
            margin: 15px 0;
            line-height: 1.6;
        }

        #detail-stats {
            font-size: 12px;
            color: #999;
            margin-bottom: 15px;
        }

        .review-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .review-btn {
            flex: 1;
            padding: 15px 10px;
            border-radius: 10px;
            cursor: pointer;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s;
        }

        .review-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .review-btn.again {
            background: var(--danger);
        }

        .review-btn.hard {
            background: var(--warning);
        }

        .review-btn.easy {
            background: var(--success);
        }

        /* çŠ¶æ€æç¤º */
        #toast {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            max-width: 80%;
            text-align: center;
        }

        /* å¯åŠ¨/å¸®åŠ©é®ç½© */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            flex-direction: column;
            z-index: 200;
            backdrop-filter: blur(5px);
        }

        .key-badge {
            background: #444;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ† */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        #joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: relative;
        }

        #joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }

            #action-bar {
                bottom: 10px;
            }

            .action-btn {
                padding: 8px 16px;
                font-size: 12px;
            }
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <!-- ç•Œé¢ HUD -->
    <div id="hud">
        <!-- ä»Šæ—¥è¿›åº¦ -->
        <div id="progress-bar">
            <div class="progress-item">
                ğŸ“š å¾…å­¦ä¹ : <span class="progress-num" id="new-count">0</span>
            </div>
            <div class="progress-item">
                ğŸ”„ å¾…å¤ä¹ : <span class="progress-num" id="review-count">0</span>
            </div>
            <div class="progress-item">
                âœ… å·²å®Œæˆ: <span class="progress-num" id="done-count">0</span>
            </div>
        </div>

        <div id="crosshair"></div>
        <div id="toast"></div>

        <!-- æ‰‹æŒå¡ç‰‡æç¤º -->
        <div id="holding-bar">
            <span id="holding-word">WORD</span>
            <div id="holding-hint">æ­£åœ¨å¯»æ‰¾ä½ç½®... (ç‚¹å‡»ç»¿è‰²å…‰åœˆæ”¾ç½®)</div>
        </div>

        <div id="action-bar">
            <button class="action-btn" onclick="openImportModal()">ğŸ“¥ å¯¼å…¥</button>
            <button class="action-btn" onclick="openInputModal()">â• æ·»åŠ </button>
            <button class="action-btn warning" onclick="autoNavigateToNextReview()">ğŸ¯ è‡ªåŠ¨å¤ä¹ </button>
            <button class="action-btn" onclick="openDataModal()">ğŸ’¾ å¤‡ä»½</button>
            <button class="action-btn primary" onclick="startApp()">ğŸ® å¼€å§‹</button>
        </div>
    </div>

    <!-- ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ† -->
    <div id="mobile-controls">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>

    <!-- å¯¼å…¥å¼¹çª— -->
    <div id="import-modal" class="modal">
        <h3>ğŸ“¥ æ‰¹é‡å¯¼å…¥</h3>
        <p style="font-size:12px; color:#666; margin-bottom:5px;">
            æ¯è¡Œä¸€ä¸ªè¯,æ ¼å¼: <code>å•è¯ [tab/é€—å·] é‡Šä¹‰</code>
        </p>
        <textarea id="import-text" placeholder="Apple è‹¹æœ&#10;Banana é¦™è•‰&#10;Serendipity æ„å¤–å‘ç°"></textarea>
        <div class="modal-footer">
            <button class="action-btn" style="background:#64748b; padding:8px 16px;"
                onclick="closeAllModals()">å–æ¶ˆ</button>
            <button class="action-btn primary" style="padding:8px 16px;" onclick="processImport()">ç¡®è®¤å¯¼å…¥</button>
        </div>
    </div>

    <!-- å•ä¸ªæ·»åŠ å¼¹çª— -->
    <div id="input-modal" class="modal" style="width: 300px;">
        <h3>ğŸ“ æ·»åŠ æ–°å¡ç‰‡</h3>
        <input type="text" id="inp-word" placeholder="å•è¯">
        <input type="text" id="inp-mean" placeholder="é‡Šä¹‰">
        <div class="modal-footer">
            <button class="action-btn" style="background:#64748b; padding:8px 16px;"
                onclick="closeAllModals()">å–æ¶ˆ</button>
            <button class="action-btn primary" style="padding:8px 16px;" onclick="confirmSingleInput()">æ·»åŠ </button>
        </div>
    </div>

    <!-- æ•°æ®ç®¡ç†å¼¹çª— -->
    <div id="data-modal" class="modal">
        <h3>ğŸ’¾ æ•°æ®ç®¡ç†</h3>
        <div style="margin-bottom: 15px;">
            <button class="action-btn success" style="width: 100%; justify-content: center; margin-bottom: 10px;"
                onclick="exportData()">â¬‡ï¸ å¯¼å‡ºå¤‡ä»½ (JSON)</button>
            <button class="action-btn primary" style="width: 100%; justify-content: center; margin-bottom: 10px;"
                onclick="document.getElementById('import-file').click()">â¬†ï¸ å¯¼å…¥å¤‡ä»½</button>
            <input type="file" id="import-file" accept=".json" style="display:none;" onchange="importData(event)">
            <button class="action-btn" style="width: 100%; justify-content: center; background: var(--danger);"
                onclick="confirmResetData()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æ•°æ®</button>
        </div>
        <div style="font-size: 12px; color: #666; margin-top: 10px;">
            <strong>å½“å‰æ•°æ®:</strong><br>
            æ€»å¡ç‰‡æ•°: <span id="total-cards">0</span><br>
            å·²æ”¾ç½®: <span id="placed-cards">0</span>
        </div>
        <div class="modal-footer">
            <button class="action-btn" style="padding:8px 16px;" onclick="closeAllModals()">å…³é—­</button>
        </div>
    </div>

    <!-- Tooltip -->
    <div id="tooltip"
        style="position: absolute; top: 50%; left: 55%; transform: translateY(-50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 15px; border-radius: 8px; pointer-events: none; opacity: 0; transition: opacity 0.3s; max-width: 200px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); z-index: 1000;">
    </div>

    <!-- è¯¦æƒ…/å¤ä¹ å¡ç‰‡ - Dashboard -->
    <div id="detail-card" class="modal"
        style="width: 800px; max-width: 90vw; background: #0f172a; color: white; border: 1px solid #334155; padding: 30px;">
        <div style="display: flex; gap: 30px; flex-wrap: wrap;">
            <!-- Left: Word & Audio -->
            <div
                style="flex: 1; min-width: 200px; text-align: center; border-right: 1px solid #334155; padding-right: 20px;">
                <h1 id="detail-word"
                    style="font-size: 56px; margin: 0; font-family: 'Times New Roman', serif; color: white;">Word</h1>
                <div id="detail-phonetic"
                    style="color: #94a3b8; font-size: 24px; margin-bottom: 20px; font-family: sans-serif;">/wÉœËd/</div>
                <button class="action-btn primary"
                    style="width: 100%; padding: 12px; font-size: 16px; justify-content: center;"
                    onclick="playCurrentAudio()">
                    ğŸ”Š æ’­æ”¾å‘éŸ³
                </button>
            </div>

            <!-- Middle: Meanings -->
            <div style="flex: 2; min-width: 300px;">
                <div id="detail-meanings" style="max-height: 300px; overflow-y: auto; padding-right: 10px;">
                    <!-- Dynamic Content -->
                </div>
                <div id="detail-example"
                    style="margin-top: 20px; padding: 15px; background: #1e293b; border-radius: 8px; font-style: italic; color: #cbd5e1; border-left: 4px solid #3b82f6;">
                    "Example sentence..."
                </div>
            </div>

            <!-- Right: Stats & Actions -->
            <div
                style="flex: 1; min-width: 150px; border-left: 1px solid #334155; padding-left: 20px; display: flex; flex-direction: column;">
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 12px; color: #94a3b8; margin-bottom: 5px;">å½“å‰é˜¶æ®µ</div>
                    <div id="card-stage" style="font-size: 24px; font-weight: bold; color: #fbbf24;">Level 0</div>

                    <div style="font-size: 12px; color: #94a3b8; margin-top: 15px; margin-bottom: 5px;">ä¸‹æ¬¡å¤ä¹ </div>
                    <div id="card-next" style="font-size: 18px;">ç°åœ¨</div>
                </div>

                <div class="review-buttons" style="flex-direction: column; gap: 10px; margin-top: auto;">
                    <button class="review-btn again" style="width: 100%;" onclick="reviewCard('again')">
                        å¿˜è®° <span style="font-size:11px; opacity:0.7;">1m</span>
                    </button>
                    <button class="review-btn hard" style="width: 100%;" onclick="reviewCard('hard')">
                        æ¨¡ç³Š <span id="hard-interval" style="font-size:11px; opacity:0.7;">10m</span>
                    </button>
                    <button class="review-btn easy" style="width: 100%;" onclick="reviewCard('easy')">
                        è®°å¾— <span id="easy-interval" style="font-size:11px; opacity:0.7;">1d</span>
                    </button>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px; text-align: right; border-top: 1px solid #334155; padding-top: 15px;">
            <button class="action-btn"
                style="padding:6px 16px; background:#ef4444; border-color:#ef4444; font-size:12px;"
                onclick="deleteCurrentCard()">ğŸ—‘ï¸ åˆ é™¤æ­¤å¡</button>
            <button class="action-btn" style="padding:6px 16px; background:#94a3b8; font-size:12px;"
                onclick="closeAllModals()">å…³é—­</button>
        </div>
    </div>

    <!-- å¯åŠ¨é¡µ -->
    <div id="overlay" onclick="startApp()">
        <h1 style="font-size: 36px; margin-bottom: 20px;">ğŸ§  è®°å¿†å®«æ®¿ Â· SRSæ™ºèƒ½å¤ä¹ </h1>
        <div style="text-align: left; line-height: 2; color: #ccc; max-width: 600px; padding: 0 20px;">
            <strong style="color: #fbbf24;">æ ¸å¿ƒåŠŸèƒ½:</strong><br>
            âœ… é—´éš”é‡å¤ç®—æ³• (SuperMemo-2) - ç§‘å­¦å¤ä¹ <br>
            âœ… è‡ªåŠ¨å¯¼èˆªåˆ°å¾…å¤ä¹ å¡ç‰‡ - æ— éœ€æ‰‹åŠ¨å¯»æ‰¾<br>
            âœ… æ•°æ®å¯¼å…¥å¯¼å‡º - æ°¸ä¸ä¸¢å¤±è¿›åº¦<br>
            âœ… ç§»åŠ¨ç«¯/æ¡Œé¢ç«¯å…¨é€‚é…<br>
            <br>
            <strong style="color: #10b981;">ä½¿ç”¨è¯´æ˜:</strong><br>
            1. ç‚¹å‡» <span class="key-badge">å¯¼å…¥</span> æ‰¹é‡å¯¼å…¥å•è¯<br>
            2. ç‚¹å‡» <span class="key-badge">è‡ªåŠ¨å¤ä¹ </span> è·³è½¬åˆ°å¾…å­¦å¡ç‰‡<br>
            3. æ‹¿èµ·å¡ç‰‡,åœ¨æˆ¿é—´ä¸­æ‰¾ç»¿è‰²å…‰åœˆæ”¾ç½®<br>
            4. çœ‹ç€å¡ç‰‡æŒ‰ <span class="key-badge">E</span> æˆ–ç‚¹å‡»å¤ä¹ <br>
            5. æ ¹æ®è®°å¿†æƒ…å†µé€‰æ‹© å¿˜è®°/æ¨¡ç³Š/è®°å¾—
        </div>
        <div
            style="margin-top: 40px; padding: 12px 30px; border: 2px solid white; border-radius: 30px; cursor: pointer; font-weight: bold;">
            ç‚¹å‡»ä»»æ„å¤„å¼€å§‹
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // =========================
        // å…¨å±€çŠ¶æ€ä¸é…ç½®
        // =========================
        const SRS_CONFIG = {
            INTERVALS_MINUTES: {
                again: 1,
                hard: 10,
                easy_new: 1440,      // 1å¤©
                easy_learning: 4320, // 3å¤©
                multiplier: 2.5      // æ¯æ¬¡æ­£ç¡®åé—´éš”å€å¢
            }
        };

        const state = {
            mode: 'ROAM', // ROAM | HOLDING | AUTO_NAVIGATE
            pendingQueue: [], // å¾…å­¦ä¹  [{id, text, meaning, nextReview, interval, stage}]
            placedWords: [],  // å·²æ”¾ç½® [{..., locusId, mesh}]
            loci: [],         // æ‰€æœ‰é”šç‚¹

            // ç»Ÿè®¡
            todayReviewedCount: 0,

            // è¿è¡Œæ—¶
            holdingWord: null,
            hoveredObj: null,
            hoveredLocus: null,
            currentDetailData: null,

            // è‡ªåŠ¨å¯¼èˆª
            autoNavTarget: null,
            autoNavStartPos: null,
            autoNavStartTime: 0,

            // ç§»åŠ¨ç«¯
            isMobile: /Android|iPhone|iPad/i.test(navigator.userAgent),
            joystickActive: false,
            joystickDir: { x: 0, y: 0 }
        };

        // Three.js æ ¸å¿ƒå¯¹è±¡
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let inboxMesh = null;
        let inboxLabel = null;
        const cardGeometry = new THREE.PlaneGeometry(0.3, 0.15);
        const ghostMaterial = new THREE.MeshBasicMaterial({
            color: 0x22c55e,
            opacity: 0.5,
            transparent: true,
            side: THREE.DoubleSide
        });

        // ç§»åŠ¨æ§åˆ¶
        let moveF = false, moveB = false, moveL = false, moveR = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // =========================
        // åˆå§‹åŒ–
        // =========================
        // =========================
        // åˆå§‹åŒ–
        // =========================
        // init(); // Moved to bottom
        // animate(); // Moved to bottom

        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f5f9);
            scene.fog = new THREE.Fog(0xf1f5f9, 0, 20);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 3);

            // ç¯å…‰
            const hemi = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.7);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xfff7ed, 0.8);
            dir.position.set(5, 8, 5);
            dir.castShadow = true;
            scene.add(dir);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new PointerLockControls(camera, document.body);
            controls.addEventListener('unlock', () => {
                if (state.mode !== 'AUTO_NAVIGATE') {
                    document.getElementById('action-bar').style.display = 'flex';
                }
            });
            controls.addEventListener('lock', () => {
                document.getElementById('action-bar').style.display = 'none';
                closeAllModals();
            });

            // äº‹ä»¶
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onResize);

            // ç§»åŠ¨ç«¯æ‘‡æ†
            if (state.isMobile) {
                initMobileControls();
            }

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(0, 0);

            // æ„å»ºæˆ¿é—´
            buildRoom();

            // åŠ è½½æ•°æ®
            loadData();
            updateInboxVisuals();
            updateProgressBar();
        }

        // =========================
        // åœºæ™¯æ„å»º - æ”¯æŒæ‰©å±•
        // =========================
        function buildRoom() {
            const matFloor = new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.5 });
            const matWall = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const matWood = new THREE.MeshStandardMaterial({ color: 0xd4a373 });
            const matTable = new THREE.MeshStandardMaterial({ color: 0xe2e8f0 });

            // åœ°æ¿
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), matFloor);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // å¢™
            const wallN = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 0.5), matWall);
            wallN.position.set(0, 2, -6);
            scene.add(wallN);
            const wallS = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 0.5), matWall);
            wallS.position.set(0, 2, 6);
            scene.add(wallS);
            const wallW = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 12), matWall);
            wallW.position.set(-6, 2, 0);
            scene.add(wallW);
            const wallE = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 12), matWall);
            wallE.position.set(6, 2, 0);
            scene.add(wallE);

            // èŒ¶å‡  (Inbox)
            const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 1.2), matTable);
            table.position.set(0, 0.25, 0);
            table.castShadow = true;
            scene.add(table);
            createInboxStack(0, 0.51, 0);

            // å®¶å…·ä¸é”šç‚¹ - åˆå§‹15ä¸ª
            createProp(-3, 0.4, -5, 2.5, 0.8, 0.8, matWood);
            addLocus(-3.5, 0.81, -5, -Math.PI / 2, 0, 0);
            addLocus(-2.5, 0.81, -5, -Math.PI / 2, 0, 0);

            createProp(-3, 1.5, -5.2, 2, 1.2, 0.1, new THREE.MeshStandardMaterial({ color: 0x111 }));
            addLocus(-3, 1.5, -5.14, 0, 0, 0);

            createProp(3, 1.2, -5, 1.2, 2.4, 1.2, new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.3 }));
            addLocus(3, 1.8, -4.39, 0, 0, 0);
            addLocus(3, 1.2, -4.39, 0, 0, 0);
            addLocus(2.39, 1.5, -5, 0, -Math.PI / 2, 0);

            addLocus(0, 2, 5.7, 0, Math.PI, 0);
            addLocus(-2, 2, 5.7, 0, Math.PI, 0);
            addLocus(2, 2, 5.7, 0, Math.PI, 0);

            createProp(-5.5, 1.5, 0, 1, 3, 2, matWood);
            addLocus(-4.99, 2.0, 0, 0, Math.PI / 2, 0);
            addLocus(-4.99, 1.2, 0.5, 0, Math.PI / 2, 0);

            // å¢™é¢é¢å¤–é”šç‚¹ - æ‰©å±•å®¹é‡
            addLocus(-5.7, 1.5, -3, 0, -Math.PI / 2, 0);
            addLocus(-5.7, 2.5, -3, 0, -Math.PI / 2, 0);
            addLocus(-5.7, 1.5, 3, 0, -Math.PI / 2, 0);
            addLocus(-5.7, 2.5, 3, 0, -Math.PI / 2, 0);

            addLocus(5.7, 1.5, -3, 0, Math.PI / 2, 0);
            addLocus(5.7, 2.5, -3, 0, Math.PI / 2, 0);
            addLocus(5.7, 1.5, 3, 0, Math.PI / 2, 0);
            addLocus(5.7, 2.5, 3, 0, Math.PI / 2, 0);

            // =========================
            // æ–°å¢å®¶å±… - è®¾è®¡æ„Ÿå‡çº§
            // =========================

            // 1. ç°ä»£ç®€çº¦æ²™å‘ (Sofa) - ä½äºå—ä¾§ï¼Œé¢å‘ä¸­å¿ƒ
            const matSofaFabric = new THREE.MeshStandardMaterial({ color: 0x475569, roughness: 0.9 });

            // æ²™å‘åº•åº§
            const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.4, 1.0), matSofaFabric);
            sofaBase.position.set(0, 0.2, 3.5);
            sofaBase.castShadow = true;
            sofaBase.receiveShadow = true;
            scene.add(sofaBase);

            // æ²™å‘é èƒŒ
            const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.5, 0.2), matSofaFabric);
            sofaBack.position.set(0, 0.65, 3.9);
            sofaBack.castShadow = true;
            scene.add(sofaBack);

            // æ²™å‘æ‰¶æ‰‹ (å·¦/å³)
            const sofaArmL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 1.0), matSofaFabric);
            sofaArmL.position.set(-1.45, 0.3, 3.5);
            scene.add(sofaArmL);
            const sofaArmR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 1.0), matSofaFabric);
            sofaArmR.position.set(1.45, 0.3, 3.5);
            scene.add(sofaArmR);

            // é”šç‚¹: æ²™å‘é èƒŒå’Œåå«
            addLocus(-0.8, 0.7, 3.8, -0.2, 0, 0); // é èƒŒå·¦
            addLocus(0.8, 0.7, 3.8, -0.2, 0, 0);  // é èƒŒå³
            addLocus(-0.8, 0.41, 3.2, -Math.PI / 2, 0, 0); // åå«å·¦
            addLocus(0.8, 0.41, 3.2, -Math.PI / 2, 0, 0);  // åå«å³

            // 2. è‰ºæœ¯ç”»å»Šå¢™ (Gallery Wall) - ä¸œå¢™
            const matFrame = new THREE.MeshStandardMaterial({ color: 0x1e293b });
            const matArt1 = new THREE.MeshStandardMaterial({ color: 0xfca5a5 }); // Pinkish
            const matArt2 = new THREE.MeshStandardMaterial({ color: 0x93c5fd }); // Blueish
            const matArt3 = new THREE.MeshStandardMaterial({ color: 0xfde047 }); // Yellowish

            function createPainting(x, y, z, w, h, mat) {
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, h, w), matFrame);
                frame.position.set(x, y, z);
                scene.add(frame);
                const canvas = new THREE.Mesh(new THREE.PlaneGeometry(w - 0.1, h - 0.1), mat);
                canvas.position.set(x - 0.06, y, z);
                canvas.rotation.y = -Math.PI / 2;
                scene.add(canvas);
                // é”šç‚¹
                addLocus(x - 0.1, y, z, 0, Math.PI / 2, 0);
            }

            createPainting(5.95, 2.5, -1.5, 1.2, 1.5, matArt1);
            createPainting(5.95, 2.5, 0.5, 1.2, 1.0, matArt2);
            createPainting(5.95, 1.2, 0.5, 1.2, 1.0, matArt3);

            // 3. ç»¿æ¤è§’è½ (Plant Corner) - è¥¿å—è§’
            const matPot = new THREE.MeshStandardMaterial({ color: 0xd97706 });
            const matLeaf = new THREE.MeshStandardMaterial({ color: 0x15803d });

            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.6, 16), matPot);
            pot.position.set(-5, 0.3, 5);
            pot.castShadow = true;
            scene.add(pot);

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0x4b3621 }));
            trunk.position.set(-5, 1.0, 5);
            scene.add(trunk);

            // æ ‘å¶ (ç®€åŒ–ä¸ºå‡ ä¸ªçƒä½“)
            const leaf1 = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), matLeaf);
            leaf1.position.set(-5, 1.8, 5);
            scene.add(leaf1);
            const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), matLeaf);
            leaf2.position.set(-4.6, 1.5, 5);
            scene.add(leaf2);

            // é”šç‚¹: æ ‘å¶ä¸Š
            addLocus(-5, 1.8, 4.4, 0, 0, 0);
            addLocus(-4.5, 1.5, 4.8, 0, -Math.PI / 4, 0);

            // 4. ç”¨é¤åŒº (Dining Area) - ä¸œå—è§’
            const matDiningTable = new THREE.MeshStandardMaterial({ color: 0xf1f5f9, metalness: 0.1 });
            const diningTableTop = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.1, 32), matDiningTable);
            diningTableTop.position.set(3.5, 0.8, 3.5);
            diningTableTop.receiveShadow = true;
            scene.add(diningTableTop);

            const diningLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.4, 0.8, 16), new THREE.MeshStandardMaterial({ color: 0x334155 }));
            diningLeg.position.set(3.5, 0.4, 3.5);
            scene.add(diningLeg);

            // æ¤…å­
            function createChair(x, z, rot) {
                const chairMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8 });
                const seat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.5), chairMat);
                seat.position.set(x, 0.45, z);
                seat.rotation.y = rot;
                scene.add(seat);

                const back = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.05), chairMat);
                back.position.set(0, 0.25, -0.22);
                seat.add(back); // Attach back to seat for easier rotation

                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.45, 0.05), chairMat);
                leg.position.set(0, -0.225, 0);
                seat.add(leg);

                // é”šç‚¹
                addLocus(x, 0.8, z, 0, rot + Math.PI, 0); // æ¤…å­èƒŒåçš„é”šç‚¹
            }

            createChair(3.5, 2.2, 0); // North side
            createChair(3.5, 4.8, Math.PI); // South side
            createChair(5.2, 3.5, -Math.PI / 2); // West side

            // é¤æ¡Œä¸Šçš„é”šç‚¹
            addLocus(3.5, 0.9, 3.5, -Math.PI / 2, 0, 0);

            // 5. åœ°æ¯¯ (Rug) - ä¸­å¿ƒåŒºåŸŸ
            const matRug = new THREE.MeshStandardMaterial({ color: 0xe2e8f0, roughness: 1.0 });
            const rug = new THREE.Mesh(new THREE.PlaneGeometry(5, 7), matRug);
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(0, 0.01, 1); // ç¨å¾®æŠ¬é«˜ä¸€ç‚¹ç‚¹é˜²æ­¢z-fighting
            rug.receiveShadow = true;
            scene.add(rug);

            // 6. è½åœ°ç¯ (Floor Lamp) - æ²™å‘æ—
            const lampPole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            lampPole.position.set(-2.5, 1.25, 3.5);
            scene.add(lampPole);

            const lampShade = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.5, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0xfff7ed, emissive: 0xffedd5, emissiveIntensity: 0.5, side: THREE.DoubleSide }));
            lampShade.position.set(-2.5, 2.3, 3.5);
            scene.add(lampShade);

            // ç¯å…‰
            const pointLight = new THREE.PointLight(0xffaa00, 0.5, 5);
            pointLight.position.set(-2.5, 2.2, 3.5);
            scene.add(pointLight);

            // é”šç‚¹
            addLocus(-2.5, 2.3, 3.5, 0, 0, 0);

            // å¯ç»§ç»­æ‰©å±•: åŠ¨æ€ç”Ÿæˆæ›´å¤šæˆ¿é—´/å¢™é¢
        }

        function createProp(x, y, z, w, h, d, mat) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        }

        function addLocus(x, y, z, rx, ry, rz) {
            state.loci.push({
                id: `loc_${state.loci.length}`,
                pos: new THREE.Vector3(x, y, z),
                rot: new THREE.Euler(rx, ry, rz),
                occupied: false,
                ghost: null
            });
        }

        function createInboxStack(x, y, z) {
            const geo = new THREE.BoxGeometry(0.32, 0.05, 0.17);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            inboxMesh = new THREE.Mesh(geo, mat);
            inboxMesh.position.set(x, y, z);
            inboxMesh.visible = false;
            inboxMesh.name = "INBOX_STACK";
            scene.add(inboxMesh);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            inboxLabel = new THREE.Sprite(spriteMat);
            inboxLabel.position.set(x, y + 0.3, z);
            inboxLabel.scale.set(0.8, 0.4, 1);
            inboxLabel.visible = false;
            scene.add(inboxLabel);
        }

        function updateInboxVisuals() {
            const count = state.pendingQueue.length;

            if (count > 0) {
                inboxMesh.visible = true;
                inboxLabel.visible = true;

                const tex = inboxLabel.material.map;
                const ctx = tex.image.getContext('2d');
                ctx.clearRect(0, 0, 256, 128);

                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.beginPath();
                ctx.roundRect(28, 14, 200, 100, 20);
                ctx.fill();

                ctx.fillStyle = "white";
                ctx.font = "bold 36px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(`å¾…å­¦ä¹ : ${count}`, 128, 50);

                ctx.font = "20px Arial";
                ctx.fillStyle = "#fbbf24";
                const nextWord = state.pendingQueue[0].text;
                ctx.fillText(nextWord.length > 10 ? nextWord.slice(0, 9) + "..." : nextWord, 128, 90);

                tex.needsUpdate = true;

                inboxMesh.scale.y = Math.min(count, 10);
                inboxMesh.position.y = 0.51 + (inboxMesh.geometry.parameters.height * inboxMesh.scale.y / 2);

            } else {
                inboxMesh.visible = false;
                inboxLabel.visible = false;
            }
        }

        // =========================
        // SRS ç®—æ³•æ ¸å¿ƒ
        // =========================
        function calculateNextReview(currentStage, response) {
            let intervalMinutes = 0;
            let newStage = currentStage;

            if (response === 'again') {
                intervalMinutes = SRS_CONFIG.INTERVALS_MINUTES.again;
                newStage = Math.max(0, currentStage - 1);
            } else if (response === 'hard') {
                intervalMinutes = SRS_CONFIG.INTERVALS_MINUTES.hard;
                newStage = currentStage;
            } else if (response === 'easy') {
                if (currentStage === 0) {
                    intervalMinutes = SRS_CONFIG.INTERVALS_MINUTES.easy_new;
                    newStage = 1;
                } else if (currentStage === 1) {
                    intervalMinutes = SRS_CONFIG.INTERVALS_MINUTES.easy_learning;
                    newStage = 2;
                } else {
                    // å·²å­¦ä¼šçš„å¡ç‰‡,æ¯æ¬¡é—´éš”å€å¢
                    const lastInterval = SRS_CONFIG.INTERVALS_MINUTES.easy_learning;
                    intervalMinutes = lastInterval * Math.pow(SRS_CONFIG.INTERVALS_MINUTES.multiplier, currentStage - 1);
                    newStage = Math.min(currentStage + 1, 10); // æœ€é«˜10çº§
                }
            }

            const nextReview = Date.now() + (intervalMinutes * 60 * 1000);
            return { nextReview, newStage, intervalMinutes };
        }

        function formatInterval(minutes) {
            if (minutes < 60) return `${Math.round(minutes)}åˆ†é’Ÿ`;
            if (minutes < 1440) return `${Math.round(minutes / 60)}å°æ—¶`;
            return `${Math.round(minutes / 1440)}å¤©`;
        }

        function isCardDue(card) {
            return Date.now() >= card.nextReview;
        }

        function getCardStyle(card) {
            if (!isCardDue(card)) {
                return { color: 0xffffff, emissive: 0x000000, emissiveIntensity: 0 };
            }
            // éœ€è¦å¤ä¹  - çº¢è‰²å‘å…‰
            return { color: 0xff6b6b, emissive: 0xff0000, emissiveIntensity: 0.3 };
        }

        // =========================
        // æ ¸å¿ƒå¾ªç¯
        // =========================
        function animate() {
            requestAnimationFrame(animate);
            const delta = (performance.now() - prevTime) / 1000;
            prevTime = performance.now();

            // è‡ªåŠ¨å¯¼èˆªæ¨¡å¼
            if (state.mode === 'AUTO_NAVIGATE' && state.autoNavTarget) {
                updateAutoNavigation(delta);
            } else if (controls.isLocked) {
                // æ‰‹åŠ¨ç§»åŠ¨
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                if (state.isMobile && state.joystickActive) {
                    direction.z = -state.joystickDir.y;
                    direction.x = state.joystickDir.x;
                } else {
                    direction.z = Number(moveF) - Number(moveB);
                    direction.x = Number(moveR) - Number(moveL);
                }
                direction.normalize();

                if (direction.z !== 0) velocity.z -= direction.z * 40.0 * delta;
                if (direction.x !== 0) velocity.x -= direction.x * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // å°„çº¿æ£€æµ‹
                updateRaycaster();
            }

            // æ›´æ–°å¡ç‰‡è§†è§‰çŠ¶æ€ (å¤ä¹ æé†’)
            updateCardVisuals();

            renderer.render(scene, camera);
        }

        function updateCardVisuals() {
            state.placedWords.forEach(card => {
                if (!card.mesh) return;
                const style = getCardStyle(card);

                // æ›´æ–°æè´¨
                if (card.mesh.material.emissive) {
                    card.mesh.material.emissive.setHex(style.emissive);
                    card.mesh.material.emissiveIntensity = style.emissiveIntensity;
                }
            });
        }

        function updateRaycaster() {
            raycaster.setFromCamera(mouse, camera);
            const crosshair = document.getElementById('crosshair');

            // æ‹¿ç€å¡ç‰‡ -> æ‰¾ç©ºä½
            if (state.mode === 'HOLDING') {
                let nearest = null;
                let minDist = 4;

                state.loci.forEach(l => {
                    if (l.occupied) return;
                    const dist = l.pos.distanceTo(camera.position);
                    const dirToObj = l.pos.clone().sub(camera.position).normalize();
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);

                    if (dist < minDist && camDir.angleTo(dirToObj) < 0.5) {
                        minDist = dist;
                        nearest = l;
                    }
                });

                state.loci.forEach(l => {
                    if (l.ghost && !l.occupied) {
                        if (l === nearest) {
                            l.ghost.visible = true;
                            l.ghost.scale.set(1.2, 1.2, 1.2);
                            l.ghost.material.opacity = 0.8;
                        } else {
                            l.ghost.visible = true;
                            l.ghost.scale.set(1, 1, 1);
                            l.ghost.material.opacity = 0.2;
                        }
                    }
                });

                state.hoveredLocus = nearest;
                return;
            }

            // æ¼«æ¸¸æ¨¡å¼ -> æ£€æµ‹ Inbox æˆ– Cards
            state.hoveredLocus = null;

            if (inboxMesh && inboxMesh.visible) {
                const intersectInbox = raycaster.intersectObject(inboxMesh);
                if (intersectInbox.length > 0 && intersectInbox[0].distance < 3) {
                    crosshair.style.transform = "translate(-50%, -50%) scale(1.5)";
                    crosshair.style.borderColor = "#fbbf24";
                    state.hoveredObj = "INBOX";
                    showToast("å·¦é”®æ‹¿èµ·å¡ç‰‡");
                    return;
                }
            }

            const meshes = state.placedWords.map(w => w.mesh).filter(m => m);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0 && intersects[0].distance < 3) {
                const obj = intersects[0].object;

                // Hover Logic
                if (state.hoveredObj !== obj) {
                    state.hoveredObj = obj;
                    state.hoverStartTime = Date.now();
                    state.hasTriggeredHover = false;
                } else {
                    // Hovering same object
                    if (!state.hasTriggeredHover && Date.now() - state.hoverStartTime > 500) {
                        // Trigger Hover Effect (Audio + Tooltip)
                        triggerHoverEffect(obj.userData);
                        state.hasTriggeredHover = true;
                    }
                }

                crosshair.style.transform = "translate(-50%, -50%) scale(1.5)";
                crosshair.style.borderColor = "#3b82f6";

                const card = obj.userData;
                if (isCardDue(card)) {
                    showToast("æŒ‰ E å¤ä¹  (è¯¥å¤ä¹ äº†!)");
                } else {
                    showToast("æŒ‰ E æŸ¥çœ‹");
                }
                return;
            }

            // Reset Hover
            if (state.hoveredObj && typeof state.hoveredObj === 'object') {
                hideTooltip();
            }
            state.hoveredObj = null;
            state.hoverStartTime = 0;
            state.hasTriggeredHover = false;

            crosshair.style.transform = "translate(-50%, -50%) scale(1)";
            crosshair.style.borderColor = "rgba(0,0,0,0.5)";
            showToast("");
        }

        function triggerHoverEffect(wordData) {
            // 1. Audio
            const rich = wordData.richData;
            if (rich && rich.audio) {
                playAudio(rich.audio);
            }

            // 2. Tooltip
            showTooltip(wordData);
        }

        let currentAudio = null;
        function playAudio(url) {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            const audio = new Audio(url);
            audio.volume = 0.5;
            audio.play().catch(e => console.log("Audio play failed (interaction needed)", e));
            currentAudio = audio;
        }

        function showTooltip(wordData) {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return; // Need to add tooltip element to HTML

            const mean = wordData.meaning || "æš‚æ— é‡Šä¹‰";
            tooltip.innerHTML = `<strong>${wordData.text}</strong><br><span style="font-size:12px; color:#ccc">${mean}</span>`;
            tooltip.style.opacity = 1;
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) tooltip.style.opacity = 0;
        }

        // =========================
        // è‡ªåŠ¨å¯¼èˆª
        // =========================
        window.autoNavigateToNextReview = function () {
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéœ€è¦å¤ä¹ æˆ–æ–°å­¦ä¹ çš„å¡ç‰‡
            let target = null;

            // ä¼˜å…ˆæ‰¾å¾…å¤ä¹ 
            for (let card of state.placedWords) {
                if (isCardDue(card)) {
                    target = card;
                    break;
                }
            }

            // æ²¡æœ‰å¾…å¤ä¹ ,æ‰¾å¾…å­¦ä¹ 
            if (!target && state.pendingQueue.length > 0) {
                // å¯¼èˆªåˆ°èŒ¶å‡ 
                target = { pos: new THREE.Vector3(0, 1.6, 2.5), isInbox: true };
            }

            if (!target) {
                showToast("ğŸ‰ å¤ªæ£’äº†!ä»Šå¤©æ²¡æœ‰éœ€è¦å¤ä¹ çš„å¡ç‰‡äº†!");
                return;
            }

            // å¼€å§‹è‡ªåŠ¨å¯¼èˆª
            state.mode = 'AUTO_NAVIGATE';
            state.autoNavTarget = target;
            state.autoNavStartPos = camera.position.clone();
            state.autoNavStartTime = Date.now();

            if (!controls.isLocked) {
                controls.lock();
            }

            showToast("ğŸ¯ æ­£åœ¨é£å‘ç›®æ ‡å¡ç‰‡...");
        };

        function updateAutoNavigation(delta) {
            const duration = 1500; // 1.5ç§’é£è¡Œæ—¶é—´
            const elapsed = Date.now() - state.autoNavStartTime;
            const progress = Math.min(elapsed / duration, 1);

            // ç¼“åŠ¨å‡½æ•°
            const easeProgress = 1 - Math.pow(1 - progress, 3);

            const targetPos = state.autoNavTarget.isInbox
                ? state.autoNavTarget.pos
                : state.autoNavTarget.mesh.position.clone().add(new THREE.Vector3(0, 0, 1.5));

            camera.position.lerpVectors(state.autoNavStartPos, targetPos, easeProgress);

            // çœ‹å‘ç›®æ ‡
            const lookTarget = state.autoNavTarget.isInbox
                ? new THREE.Vector3(0, 1, 0)
                : state.autoNavTarget.mesh.position;
            camera.lookAt(lookTarget);

            if (progress >= 1) {
                // å¯¼èˆªå®Œæˆ
                state.mode = 'ROAM';
                state.autoNavTarget = null;
                showToast("âœ… å·²åˆ°è¾¾!å¯ä»¥æ“ä½œäº†");

                // å¦‚æœæ˜¯å¡ç‰‡,è‡ªåŠ¨æ‰“å¼€è¯¦æƒ…
                if (!state.autoNavTarget?.isInbox) {
                    setTimeout(() => {
                        const card = state.placedWords.find(c => c.mesh === state.hoveredObj);
                        if (card) openDetail(card);
                    }, 300);
                }
            }
        }

        // =========================
        // äº¤äº’äº‹ä»¶
        // =========================
        function onMouseDown(e) {
            if (!controls.isLocked || state.mode === 'AUTO_NAVIGATE') return;

            if (state.mode === 'ROAM' && state.hoveredObj === "INBOX") {
                pickUpNextCard();
                return;
            }

            if (state.mode === 'HOLDING' && state.hoveredLocus) {
                placeCard(state.hoveredLocus);
                return;
            }

            if (state.mode === 'ROAM' && state.hoveredObj && typeof state.hoveredObj === 'object') {
                openDetail(state.hoveredObj.userData);
            }
        }

        function onKeyDown(e) {
            if (e.code === 'KeyE') {
                if (state.mode === 'ROAM' && state.hoveredObj && typeof state.hoveredObj === 'object') {
                    openDetail(state.hoveredObj.userData);
                }
            }
            switch (e.code) {
                case 'KeyW': moveF = true; break;
                case 'KeyS': moveB = true; break;
                case 'KeyA': moveL = true; break;
                case 'KeyD': moveR = true; break;
            }
        }

        function onKeyUp(e) {
            switch (e.code) {
                case 'KeyW': moveF = false; break;
                case 'KeyS': moveB = false; break;
                case 'KeyA': moveL = false; break;
                case 'KeyD': moveR = false; break;
            }
        }

        // =========================
        // æ ¸å¿ƒé€»è¾‘
        // =========================
        function pickUpNextCard() {
            if (state.pendingQueue.length === 0) return;

            const word = state.pendingQueue.shift();
            state.holdingWord = word;
            state.mode = 'HOLDING';

            updateInboxVisuals();
            document.getElementById('holding-bar').style.display = 'block';
            document.getElementById('holding-word').innerText = word.text;

            state.loci.forEach(l => {
                if (!l.occupied) {
                    if (!l.ghost) {
                        const g = new THREE.Mesh(cardGeometry, ghostMaterial);
                        g.position.copy(l.pos);
                        g.rotation.copy(l.rot);
                        scene.add(g);
                        l.ghost = g;
                    }
                    l.ghost.visible = true;
                }
            });

            showToast("æ‰¾åˆ°ç»¿è‰²å…‰åœˆå¹¶ç‚¹å‡»æ”¾ç½®");
        }

        function placeCard(locus) {
            const word = state.holdingWord;

            // åˆ›å»ºå¡ç‰‡ Mesh
            const tex = generateWordTexture(word);
            const mat = new THREE.MeshStandardMaterial({
                map: tex,
                emissive: 0x000000,
                emissiveIntensity: 0,
                roughness: 0.4,
                metalness: 0.1
            });
            const mesh = new THREE.Mesh(cardGeometry, mat);
            mesh.position.copy(locus.pos);
            mesh.rotation.copy(locus.rot);
            mesh.translateZ(0.01);

            mesh.userData = { ...word, locusId: locus.id };
            scene.add(mesh);

            state.placedWords.push({ ...word, locusId: locus.id, mesh: mesh });
            locus.occupied = true;

            state.mode = 'ROAM';
            state.holdingWord = null;
            document.getElementById('holding-bar').style.display = 'none';

            state.loci.forEach(l => { if (l.ghost) l.ghost.visible = false; });

            saveData();
            updateProgressBar();
            showToast("âœ… æ”¾ç½®æˆåŠŸ!");
        }

        // =========================
        // æ¸²æŸ“å±‚ - åŠ¨æ€çº¹ç†ç”Ÿæˆ
        // =========================
        function generateWordTexture(wordData) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const rich = wordData.richData || {};
            const color = rich.color || '#94a3b8'; // Default Gray
            const pos = rich.meanings?.[0]?.partOfSpeech || "";
            const phonetic = rich.phonetic || "";

            // 1. Background
            ctx.fillStyle = '#f8fafc'; // Slate-50 (Off-white)
            ctx.fillRect(0, 0, 512, 256);

            // 2. Accent Border (Bottom)
            ctx.fillStyle = color;
            ctx.fillRect(0, 240, 512, 16);

            // 3. Typography
            // Word
            ctx.fillStyle = '#1e293b'; // Slate-800
            ctx.font = 'bold 70px "Times New Roman", serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(wordData.text, 256, 100);

            // Phonetic
            if (phonetic) {
                ctx.font = '28px Arial, sans-serif';
                ctx.fillStyle = '#64748b'; // Slate-500
                ctx.fillText(phonetic, 256, 155);
            }

            // Part of Speech Tag
            if (pos) {
                ctx.font = 'italic bold 24px "Times New Roman", serif';
                ctx.fillStyle = color;
                ctx.fillText(pos, 256, 195);
            }

            // Border
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#e2e8f0';
            ctx.strokeRect(0, 0, 512, 256);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // =========================
        // æ•°æ®å±‚ - Dictionary API
        // =========================
        async function fetchWordData(word) {
            try {
                // ç®€å•ç¼“å­˜æ£€æŸ¥
                const cacheKey = `dict_cache_${word.toLowerCase()}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) return JSON.parse(cached);

                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!res.ok) throw new Error('Word not found');
                const data = await res.json();

                const processed = processWordData(data[0]);
                localStorage.setItem(cacheKey, JSON.stringify(processed));
                return processed;
            } catch (e) {
                console.warn(`Failed to fetch data for ${word}`, e);
                // Fallback data
                return {
                    word: word,
                    phonetic: '/.../',
                    audio: null,
                    meanings: [{ partOfSpeech: 'unknown', def: 'æš‚æ— é‡Šä¹‰', example: '' }],
                    color: '#94a3b8' // Gray
                };
            }
        }

        function processWordData(entry) {
            // 1. Phonetic & Audio
            let phonetic = entry.phonetic || (entry.phonetics.find(p => p.text)?.text) || "";
            let audio = entry.phonetics.find(p => p.audio && p.audio.length > 0)?.audio || null;

            // 2. Meanings (Top 2 distinct parts of speech)
            const meanings = [];
            const seenPoS = new Set();

            for (const m of entry.meanings) {
                if (seenPoS.has(m.partOfSpeech)) continue;
                if (meanings.length >= 2) break;

                const def = m.definitions[0];
                meanings.push({
                    partOfSpeech: m.partOfSpeech, // noun, verb, adjective...
                    def: def.definition,
                    example: def.example || ""
                });
                seenPoS.add(m.partOfSpeech);
            }

            // 3. Color Tagging
            const primaryPoS = meanings[0]?.partOfSpeech || 'unknown';
            let color = '#94a3b8'; // Default Gray
            if (primaryPoS === 'noun') color = '#3b82f6'; // Blue
            else if (primaryPoS === 'verb') color = '#ef4444'; // Red
            else if (primaryPoS === 'adjective') color = '#eab308'; // Yellow
            else if (primaryPoS === 'adverb') color = '#a855f7'; // Purple

            return {
                word: entry.word,
                phonetic,
                audio,
                meanings,
                color
            };
        }

        // =========================
        // UI åŠŸèƒ½
        // =========================
        window.openImportModal = function () {
            document.exitPointerLock();
            document.getElementById('import-modal').style.display = 'block';
        };

        window.processImport = async function () {
            const raw = document.getElementById('import-text').value;
            if (!raw.trim()) return;

            const lines = raw.split('\n');
            let count = 0;

            showToast("â³ æ­£åœ¨è·å–å•è¯æ•°æ®...");

            // å¹¶è¡Œå¤„ç†æ‰€æœ‰å•è¯
            const promises = lines.map(async (line) => {
                if (!line.trim()) return null;
                const parts = line.split(/[\t,ï¼Œ]/);
                const text = parts[0].trim();
                // å¦‚æœç”¨æˆ·æä¾›äº†é‡Šä¹‰ï¼Œä¼˜å…ˆä½¿ç”¨ç”¨æˆ·çš„ï¼Œå¦åˆ™ç”¨APIçš„
                const userMeaning = parts[1] ? parts[1].trim() : "";

                if (text) {
                    const richData = await fetchWordData(text);
                    return {
                        id: Date.now() + Math.random(),
                        text: richData.word, // Use corrected casing from API
                        meaning: userMeaning || richData.meanings[0]?.def || "æš‚æ— é‡Šä¹‰",
                        richData: richData,
                        nextReview: Date.now(),
                        interval: 0,
                        stage: 0
                    };
                }
                return null;
            });

            const results = await Promise.all(promises);

            results.forEach(item => {
                if (item) {
                    state.pendingQueue.push(item);
                    count++;
                }
            });

            closeAllModals();
            updateInboxVisuals();
            updateProgressBar();
            saveData();

            showToast(`âœ… æˆåŠŸå¯¼å…¥ ${count} ä¸ªå•è¯!`);
            setTimeout(() => startApp(), 1000);
        };

        window.openInputModal = function () {
            document.exitPointerLock();
            document.getElementById('input-modal').style.display = 'block';
            document.getElementById('inp-word').focus();
        };

        window.confirmSingleInput = async function () {
            const w = document.getElementById('inp-word').value.trim();
            const m = document.getElementById('inp-mean').value.trim();

            if (w) {
                showToast("â³ æ­£åœ¨è·å–æ•°æ®...");
                const richData = await fetchWordData(w);

                state.pendingQueue.push({
                    id: Date.now(),
                    text: richData.word,
                    meaning: m || richData.meanings[0]?.def || "æš‚æ— é‡Šä¹‰",
                    richData: richData,
                    nextReview: Date.now(),
                    interval: 0,
                    stage: 0
                });
                updateInboxVisuals();
                updateProgressBar();
                saveData();
            }
            closeAllModals();
            startApp();
        };

        window.openDetail = function (data) {
            document.exitPointerLock();
            state.currentDetailData = data;
            const rich = data.richData || {};

            document.getElementById('detail-card').style.display = 'block';

            // 1. Word & Phonetic
            document.getElementById('detail-word').innerText = data.text;
            document.getElementById('detail-phonetic').innerText = rich.phonetic || "/.../";

            // 2. Meanings
            const meaningsContainer = document.getElementById('detail-meanings');
            meaningsContainer.innerHTML = '';

            // Add User Meaning first (if exists and different from API)
            if (data.meaning && data.meaning !== "æš‚æ— é‡Šä¹‰") {
                const div = document.createElement('div');
                div.style.marginBottom = '15px';
                div.innerHTML = `<span style="color: #fbbf24; font-weight: bold;">[User]</span> <span style="color: #e2e8f0;">${data.meaning}</span>`;
                meaningsContainer.appendChild(div);
            }

            if (rich.meanings && rich.meanings.length > 0) {
                rich.meanings.forEach(m => {
                    const div = document.createElement('div');
                    div.style.marginBottom = '15px';
                    div.innerHTML = `
                        <span style="color: ${rich.color || '#94a3b8'}; font-weight: bold; font-style: italic; margin-right: 10px;">${m.partOfSpeech}</span>
                        <span style="color: #e2e8f0;">${m.def}</span>
                    `;
                    meaningsContainer.appendChild(div);
                });
            } else if (!data.meaning) {
                meaningsContainer.innerHTML = '<div style="color: #64748b;">æš‚æ— è¯¦ç»†é‡Šä¹‰</div>';
            }

            // 3. Example
            const example = rich.meanings?.[0]?.example || "No example sentence available.";
            // Highlight word in example
            const regex = new RegExp(`\\b${data.text}\\b`, 'gi');
            const highlighted = example.replace(regex, match => `<span style="color: #fbbf24; font-weight: bold;">${match}</span>`);
            document.getElementById('detail-example').innerHTML = `"${highlighted}"`;

            // 4. SRS Stats
            const stageNames = ['æ–°å¡ç‰‡', 'å­¦ä¹ ä¸­', 'å·²å­¦ä¼š', 'ç†Ÿç»ƒ', 'ç²¾é€š'];
            document.getElementById('card-stage').innerText = stageNames[Math.min(data.stage, 4)] || `Level ${data.stage}`;

            const nextDate = new Date(data.nextReview);
            const now = new Date();
            if (nextDate <= now) {
                document.getElementById('card-next').innerText = 'ç°åœ¨';
                document.getElementById('card-next').style.color = '#ef4444';
            } else {
                const diff = (nextDate - now) / 1000 / 60;
                document.getElementById('card-next').innerText = formatInterval(diff);
                document.getElementById('card-next').style.color = '#fff';
            }

            // Intervals
            const hardCalc = calculateNextReview(data.stage, 'hard');
            const easyCalc = calculateNextReview(data.stage, 'easy');
            document.getElementById('hard-interval').innerText = formatInterval(hardCalc.intervalMinutes);
            document.getElementById('easy-interval').innerText = formatInterval(easyCalc.intervalMinutes);
        };

        window.reviewCard = function (response) {
            if (!state.currentDetailData) return;
            const data = state.currentDetailData;

            // è®¡ç®—æ–°çš„å¤ä¹ æ—¶é—´
            const result = calculateNextReview(data.stage, response);

            // æ›´æ–°æ•°æ®
            const idx = state.placedWords.findIndex(w => w.id === data.id);
            if (idx > -1) {
                state.placedWords[idx].nextReview = result.nextReview;
                state.placedWords[idx].interval = result.intervalMinutes;
                state.placedWords[idx].stage = result.newStage;
                state.placedWords[idx].mesh.userData = state.placedWords[idx];
            }

            state.todayReviewedCount++;
            saveData();
            updateProgressBar();

            closeAllModals();
            showToast(`ä¸‹æ¬¡å¤ä¹ : ${formatInterval(result.intervalMinutes)}`);

            // è‡ªåŠ¨è·³è½¬åˆ°ä¸‹ä¸€å¼ 
            setTimeout(() => autoNavigateToNextReview(), 800);
        };

        window.deleteCurrentCard = function () {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å¡ç‰‡å—?')) return;
            if (!state.currentDetailData) return;
            const data = state.currentDetailData;

            const idx = state.placedWords.findIndex(w => w.id === data.id);
            if (idx > -1) {
                scene.remove(state.placedWords[idx].mesh);
                state.placedWords.splice(idx, 1);
            }

            const loc = state.loci.find(l => l.id === data.locusId);
            if (loc) loc.occupied = false;

            saveData();
            updateProgressBar();
            closeAllModals();
            startApp();
        };

        window.playCurrentAudio = function () {
            const data = state.currentDetailData;
            if (data && data.richData && data.richData.audio) {
                playAudio(data.richData.audio);
            } else {
                // Fallback to TTS
                const u = new SpeechSynthesisUtterance(data.text);
                u.lang = 'en-US';
                speechSynthesis.speak(u);
            }
        };

        window.openDataModal = function () {
            document.exitPointerLock();
            document.getElementById('total-cards').innerText = state.pendingQueue.length + state.placedWords.length;
            document.getElementById('placed-cards').innerText = state.placedWords.length;
            document.getElementById('data-modal').style.display = 'block';
        };

        window.exportData = function () {
            const data = {
                version: 2,
                exportDate: new Date().toISOString(),
                pending: state.pendingQueue,
                placed: state.placedWords.map(w => ({
                    id: w.id,
                    text: w.text,
                    meaning: w.meaning,
                    locusId: w.locusId,
                    nextReview: w.nextReview,
                    interval: w.interval,
                    stage: w.stage
                })),
                stats: {
                    todayReviewed: state.todayReviewedCount
                }
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `memory-palace-backup-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showToast('âœ… å¤‡ä»½å·²ä¸‹è½½!');
        };

        window.importData = function (event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // æ¸…ç©ºå½“å‰æ•°æ®
                    state.placedWords.forEach(w => scene.remove(w.mesh));
                    state.placedWords = [];
                    state.pendingQueue = [];
                    state.loci.forEach(l => l.occupied = false);

                    // å¯¼å…¥æ•°æ®
                    state.pendingQueue = data.pending || [];

                    if (data.placed) {
                        data.placed.forEach(p => {
                            const loc = state.loci.find(l => l.id === p.locusId);
                            if (loc) {
                                state.holdingWord = p;
                                placeCard(loc);
                            }
                        });
                    }

                    saveData();
                    updateInboxVisuals();
                    updateProgressBar();
                    showToast('âœ… æ•°æ®å¯¼å…¥æˆåŠŸ!');
                    closeAllModals();
                } catch (err) {
                    alert('å¯¼å…¥å¤±è´¥: æ–‡ä»¶æ ¼å¼é”™è¯¯');
                }
            };
            reader.readAsText(file);
        };

        window.confirmResetData = function () {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—?æ­¤æ“ä½œä¸å¯æ¢å¤!')) return;

            state.placedWords.forEach(w => scene.remove(w.mesh));
            state.placedWords = [];
            state.pendingQueue = [];
            state.loci.forEach(l => l.occupied = false);
            state.todayReviewedCount = 0;

            localStorage.removeItem('mp_srs_v2');
            updateInboxVisuals();
            updateProgressBar();
            closeAllModals();
            showToast('âœ… æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');
        };

        window.closeAllModals = function () {
            document.querySelectorAll('.modal').forEach(el => el.style.display = 'none');
        };

        window.startApp = function () {
            document.getElementById('overlay').style.display = 'none';
            if (!state.isMobile) {
                controls.lock();
            } else {
                // ç§»åŠ¨ç«¯ä¸ä½¿ç”¨ PointerLock
                document.getElementById('action-bar').style.display = 'none';
            }
        };

        function updateProgressBar() {
            const newCount = state.pendingQueue.length;
            const reviewCount = state.placedWords.filter(c => isCardDue(c)).length;
            const doneCount = state.todayReviewedCount;

            document.getElementById('new-count').innerText = newCount;
            document.getElementById('review-count').innerText = reviewCount;
            document.getElementById('done-count').innerText = doneCount;
        }

        // =========================
        // æ•°æ®æŒä¹…åŒ–
        // =========================
        function saveData() {
            const saveObj = {
                version: 2,
                pending: state.pendingQueue,
                placed: state.placedWords.map(w => ({
                    id: w.id,
                    text: w.text,
                    meaning: w.meaning,
                    locusId: w.locusId,
                    nextReview: w.nextReview,
                    interval: w.interval,
                    stage: w.stage
                })),
                todayReviewed: state.todayReviewedCount
            };
            localStorage.setItem('mp_srs_v2', JSON.stringify(saveObj));
        }

        function loadData() {
            const str = localStorage.getItem('mp_srs_v2');
            if (str) {
                const data = JSON.parse(str);
                state.pendingQueue = data.pending || [];
                state.todayReviewedCount = data.todayReviewed || 0;

                if (data.placed) {
                    data.placed.forEach(p => {
                        const loc = state.loci.find(l => l.id === p.locusId);
                        if (loc) {
                            state.holdingWord = p;
                            placeCard(loc);
                        }
                    });
                }
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =========================
        // ç§»åŠ¨ç«¯æ§åˆ¶
        // =========================
        function initMobileControls() {
            const base = document.getElementById('joystick-base');
            const stick = document.getElementById('joystick-stick');

            base.addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.joystickActive = true;
            });

            base.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!state.joystickActive) return;

                const touch = e.touches[0];
                const rect = base.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 35;

                if (distance > maxDistance) {
                    dx = (dx / distance) * maxDistance;
                    dy = (dy / distance) * maxDistance;
                }

                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                state.joystickDir.x = dx / maxDistance;
                state.joystickDir.y = dy / maxDistance;
            });

            base.addEventListener('touchend', () => {
                state.joystickActive = false;
                stick.style.transform = 'translate(-50%, -50%)';
                state.joystickDir.x = 0;
                state.joystickDir.y = 0;
            });
        }

        // Toast æç¤º
        let toastTimeout = null;
        function showToast(msg) {
            const toast = document.getElementById('toast');
            if (!msg) {
                toast.style.opacity = '0';
                if (toastTimeout) clearTimeout(toastTimeout);
                return;
            }
            toast.innerText = msg;
            toast.style.opacity = '1';

            if (toastTimeout) clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toast.style.opacity = '0';
            }, 3000);
        }

        // å¯åŠ¨åº”ç”¨
        init();
        animate();

    </script>
</body>

</html>