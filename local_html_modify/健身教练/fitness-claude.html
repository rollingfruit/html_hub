<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitCoach Studio - 训练视频字幕合成工作站</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- FFmpeg.wasm for video compression -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'display': ['Outfit', 'sans-serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        'surface': {
                            900: '#0a0a0b',
                            800: '#111113',
                            700: '#1a1a1d',
                            600: '#242428',
                            500: '#2d2d32',
                        },
                        'accent': {
                            primary: '#00ff88',
                            secondary: '#00d4ff',
                            warn: '#ffaa00',
                            error: '#ff4466',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1d;
        }

        ::-webkit-scrollbar-thumb {
            background: #3d3d42;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4d4d52;
        }

        /* Video container */
        .video-container {
            position: relative;
            background: #000;
        }

        .video-container video {
            display: block;
            width: 100%;
            height: auto;
        }

        /* Subtitle overlay */
        .subtitle-overlay {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            max-width: 90%;
            text-align: center;
            pointer-events: none;
        }

        .subtitle-text {
            display: inline-block;
            padding: 8px 20px;
            background: rgba(0, 0, 0, 0.75);
            border-radius: 6px;
            font-size: 1.25rem;
            font-weight: 500;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .subtitle-text.warn {
            border-left: 3px solid #ffaa00;
        }

        .subtitle-text.praise {
            border-left: 3px solid #00ff88;
        }

        .subtitle-text.tip {
            border-left: 3px solid #00d4ff;
        }

        /* HUD overlay */
        .hud-overlay {
            position: absolute;
            top: 16px;
            right: 16px;
            text-align: right;
            pointer-events: none;
        }

        .hud-score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .hud-badge {
            display: inline-block;
            padding: 4px 12px;
            margin-top: 8px;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
            color: #00ff88;
            animation: badgePop 0.3s ease-out;
        }

        @keyframes badgePop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Timeline */
        .timeline-container {
            position: relative;
            height: 60px;
            background: #1a1a1d;
        }

        .timeline-track {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            height: 20px;
            background: #242428;
            border-radius: 4px;
        }

        .timeline-segment {
            position: absolute;
            top: 0;
            height: 100%;
            border-radius: 3px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .timeline-segment:hover {
            opacity: 0.8;
        }

        .timeline-playhead {
            position: absolute;
            top: 10px;
            width: 2px;
            height: 40px;
            background: #fff;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 10;
        }

        /* Cards */
        .prompt-card {
            background: linear-gradient(135deg, #1a1a1d 0%, #111113 100%);
            border: 1px solid #2d2d32;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .prompt-card:hover {
            border-color: #3d3d42;
        }

        .prompt-card.active {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
        }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #0a0a0b;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #242428;
            color: #fff;
            font-weight: 500;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #3d3d42;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #2d2d32;
            border-color: #4d4d52;
        }

        /* Range slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #242428;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 12px 20px;
            background: #1a1a1d;
            border: 1px solid #3d3d42;
            border-radius: 8px;
            color: #fff;
            font-weight: 500;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            border-color: #00ff88;
        }

        .toast.error {
            border-color: #ff4466;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Progress bar */
        .progress-bar {
            height: 4px;
            background: #242428;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            transition: width 0.3s;
        }

        /* Segment list item */
        .segment-item {
            padding: 12px;
            background: #1a1a1d;
            border-radius: 8px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .segment-item:hover {
            border-color: #3d3d42;
        }

        .segment-item.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.05);
        }

        .segment-item.disabled {
            opacity: 0.4;
        }

        /* Export modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 100;
        }

        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111113;
            border: 1px solid #2d2d32;
            border-radius: 16px;
            padding: 32px;
            min-width: 400px;
            z-index: 101;
        }
    </style>
</head>

<body class="bg-surface-900 text-white min-h-screen" x-data="app()" x-init="init()">
    <!-- Toast Notifications -->
    <template x-if="toast.show">
        <div class="toast" :class="toast.type" x-text="toast.message" x-transition
            x-init="setTimeout(() => toast.show = false, 3000)"></div>
    </template>

    <!-- Export Modal -->
    <template x-if="showExportModal">
        <div>
            <div class="modal-backdrop" @click="showExportModal = false"></div>
            <div class="modal-content">
                <h3 class="text-xl font-semibold mb-6">导出 WebM</h3>

                <template x-if="!isExporting">
                    <div>
                        <div class="mb-4">
                            <label class="block text-sm text-gray-400 mb-2">质量档位</label>
                            <select x-model="exportSettings.quality"
                                class="w-full bg-surface-700 border border-surface-500 rounded-lg px-4 py-3 text-white">
                                <option value="high">高质量 (8 Mbps)</option>
                                <option value="ultra">极高质量 (15 Mbps)</option>
                                <option value="medium">中等质量 (4 Mbps)</option>
                            </select>
                        </div>

                        <div class="mb-4">
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input type="checkbox" x-model="exportSettings.includeHUD"
                                    class="w-5 h-5 rounded bg-surface-700 border-surface-500">
                                <span>包含 HUD（分数/徽章）</span>
                            </label>
                        </div>

                        <div class="mb-6">
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input type="checkbox" x-model="exportSettings.includeSubtitles"
                                    class="w-5 h-5 rounded bg-surface-700 border-surface-500">
                                <span>包含字幕</span>
                            </label>
                        </div>

                        <div class="flex gap-3">
                            <button @click="showExportModal = false" class="btn-secondary flex-1">取消</button>
                            <button @click="startExport()" class="btn-primary flex-1">开始导出</button>
                        </div>
                    </div>
                </template>

                <template x-if="isExporting">
                    <div class="text-center">
                        <div class="mb-4">
                            <i data-lucide="loader-2" class="w-12 h-12 mx-auto text-accent-primary animate-spin"></i>
                        </div>
                        <p class="text-lg mb-2">正在导出...</p>
                        <p class="text-sm text-gray-400 mb-4"
                            x-text="`已处理 ${exportProgress.current} / ${exportProgress.total} 帧`"></p>
                        <div class="progress-bar">
                            <div class="progress-fill"
                                :style="`width: ${(exportProgress.current / exportProgress.total * 100) || 0}%`"></div>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </template>

    <!-- Compression Modal -->
    <template x-if="showCompressModal">
        <div>
            <div class="modal-backdrop" @click="showCompressModal = false"></div>
            <div class="modal-content" style="min-width: 480px;">
                <h3 class="text-xl font-semibold mb-6 flex items-center gap-2">
                    <i data-lucide="archive" class="w-5 h-5 text-accent-secondary"></i>
                    视频压缩为 WebP
                </h3>

                <template x-if="!isCompressing">
                    <div>
                        <!-- FFmpeg loading status -->
                        <template x-if="!ffmpegLoaded">
                            <div class="mb-4 p-3 bg-accent-warn/10 border border-accent-warn/30 rounded-lg">
                                <p class="text-sm text-accent-warn flex items-center gap-2">
                                    <i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>
                                    正在加载 FFmpeg 引擎...
                                </p>
                            </div>
                        </template>

                        <template x-if="ffmpegLoaded">
                            <div class="mb-4 p-3 bg-accent-primary/10 border border-accent-primary/30 rounded-lg">
                                <p class="text-sm text-accent-primary flex items-center gap-2">
                                    <i data-lucide="check-circle" class="w-4 h-4"></i>
                                    FFmpeg 引擎已就绪
                                </p>
                            </div>
                        </template>

                        <!-- Original file info -->
                        <div class="mb-4 p-3 bg-surface-700 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">原始文件</p>
                            <p class="font-mono" x-text="formatFileSize(video.size)"></p>
                            <p class="text-xs text-gray-500 mt-1"
                                x-text="`${video.width}×${video.height} @ ${video.fps}fps`"></p>
                        </div>

                        <!-- Compression settings -->
                        <div class="mb-4">
                            <label class="block text-sm text-gray-400 mb-2">压缩质量 (越低越小)</label>
                            <select x-model="compressSettings.quality"
                                class="w-full bg-surface-700 border border-surface-500 rounded-lg px-4 py-3 text-white">
                                <option value="high">高质量 (压缩约 1/5)</option>
                                <option value="medium">中等质量 (压缩约 1/10) ★推荐</option>
                                <option value="low">低质量 (压缩约 1/20)</option>
                                <option value="ultra-low">极致压缩 (压缩约 1/30)</option>
                            </select>
                        </div>

                        <div class="mb-4">
                            <label class="block text-sm text-gray-400 mb-2">输出分辨率</label>
                            <select x-model="compressSettings.resolution"
                                class="w-full bg-surface-700 border border-surface-500 rounded-lg px-4 py-3 text-white">
                                <option value="original">保持原始分辨率</option>
                                <option value="720">720p (1280×720)</option>
                                <option value="480">480p (854×480)</option>
                                <option value="360">360p (640×360)</option>
                            </select>
                        </div>

                        <div class="mb-4">
                            <label class="block text-sm text-gray-400 mb-2">帧率</label>
                            <select x-model="compressSettings.fps"
                                class="w-full bg-surface-700 border border-surface-500 rounded-lg px-4 py-3 text-white">
                                <option value="original">保持原始帧率</option>
                                <option value="24">24 fps (电影)</option>
                                <option value="15">15 fps (省空间)</option>
                                <option value="10">10 fps (极省空间)</option>
                            </select>
                        </div>

                        <div class="mb-6">
                            <label class="block text-sm text-gray-400 mb-2">时间裁剪 (可选)</label>
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="text-xs text-gray-500">开始时间 (秒)</label>
                                    <input type="number" x-model="compressSettings.startTime" min="0"
                                        :max="video.duration" step="0.1"
                                        class="w-full bg-surface-700 border border-surface-500 rounded-lg px-3 py-2 text-sm">
                                </div>
                                <div>
                                    <label class="text-xs text-gray-500">结束时间 (秒)</label>
                                    <input type="number" x-model="compressSettings.endTime" min="0"
                                        :max="video.duration" step="0.1"
                                        class="w-full bg-surface-700 border border-surface-500 rounded-lg px-3 py-2 text-sm">
                                </div>
                            </div>
                        </div>

                        <!-- Estimated size -->
                        <div class="mb-6 p-3 bg-surface-700 rounded-lg">
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-400">预估压缩后大小</span>
                                <span class="font-mono text-accent-primary" x-text="estimateCompressedSize()"></span>
                            </div>
                            <div class="flex justify-between items-center mt-1">
                                <span class="text-xs text-gray-500">预估压缩比</span>
                                <span class="text-xs text-accent-secondary" x-text="estimateCompressionRatio()"></span>
                            </div>
                        </div>

                        <div class="flex gap-3">
                            <button @click="showCompressModal = false" class="btn-secondary flex-1">取消</button>
                            <button @click="startCompression()" class="btn-primary flex-1" :disabled="!ffmpegLoaded">
                                <i data-lucide="zap" class="w-4 h-4 inline-block mr-1"></i>
                                开始压缩
                            </button>
                        </div>
                    </div>
                </template>

                <template x-if="isCompressing">
                    <div class="text-center">
                        <div class="mb-4">
                            <i data-lucide="loader-2" class="w-12 h-12 mx-auto text-accent-secondary animate-spin"></i>
                        </div>
                        <p class="text-lg mb-2" x-text="compressProgress.stage"></p>
                        <p class="text-sm text-gray-400 mb-4" x-text="compressProgress.message"></p>
                        <div class="progress-bar">
                            <div class="progress-fill" :style="`width: ${compressProgress.percent}%`"></div>
                        </div>
                        <p class="text-xs text-gray-500 mt-2" x-text="`${compressProgress.percent.toFixed(1)}%`"></p>
                    </div>
                </template>
            </div>
        </div>
    </template>

    <!-- Header -->
    <header
        class="h-14 bg-surface-800 border-b border-surface-600 flex items-center justify-between px-4 sticky top-0 z-50">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2">
                <i data-lucide="dumbbell" class="w-6 h-6 text-accent-primary"></i>
                <span class="font-display font-semibold text-lg">FitCoach Studio</span>
            </div>
            <div class="h-6 w-px bg-surface-600"></div>
            <div class="flex items-center gap-2 text-sm">
                <span class="px-2 py-1 rounded text-xs font-mono" :class="projectStatus === 'empty' ? 'bg-surface-600 text-gray-400' : 
                              projectStatus === 'imported' ? 'bg-accent-secondary/20 text-accent-secondary' : 
                              'bg-accent-primary/20 text-accent-primary'"
                    x-text="projectStatus === 'empty' ? '未导入' : projectStatus === 'imported' ? '已导入' : '已校准'"></span>
            </div>
        </div>

        <div class="flex items-center gap-2">
            <button @click="openCompressModal()" class="btn-secondary text-sm flex items-center gap-2"
                :disabled="!video.src">
                <i data-lucide="archive" class="w-4 h-4"></i>
                压缩导出 WebP
            </button>
            <button @click="importJSON()" class="btn-secondary text-sm flex items-center gap-2">
                <i data-lucide="upload" class="w-4 h-4"></i>
                导入 JSON
            </button>
            <button @click="exportJSON()" class="btn-secondary text-sm flex items-center gap-2" :disabled="!analysis">
                <i data-lucide="download" class="w-4 h-4"></i>
                导出 JSON
            </button>
            <button @click="showExportModal = true" class="btn-primary text-sm flex items-center gap-2"
                :disabled="!video.src || !analysis">
                <i data-lucide="film" class="w-4 h-4"></i>
                导出 WebM
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex h-[calc(100vh-56px)]">
        <!-- Left Panel: Prompt Studio -->
        <aside class="w-80 bg-surface-800 border-r border-surface-600 flex flex-col overflow-hidden">
            <div class="p-4 border-b border-surface-600">
                <h2 class="font-semibold flex items-center gap-2">
                    <i data-lucide="sparkles" class="w-5 h-5 text-accent-primary"></i>
                    Prompt Studio
                </h2>
                <p class="text-sm text-gray-400 mt-1">选择场景模板，一键复制 Prompt</p>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-3">
                <template x-for="(template, index) in promptTemplates" :key="index">
                    <div class="prompt-card p-4" :class="{ 'active': selectedTemplate === index }"
                        @click="selectedTemplate = index">
                        <div class="flex items-start justify-between mb-2">
                            <h3 class="font-medium" x-text="template.name"></h3>
                            <span class="text-xs px-2 py-1 rounded-full" :class="template.style === 'coach' ? 'bg-accent-primary/20 text-accent-primary' :
                                          template.style === 'teach' ? 'bg-accent-secondary/20 text-accent-secondary' :
                                          template.style === 'score' ? 'bg-accent-warn/20 text-accent-warn' :
                                          'bg-purple-500/20 text-purple-400'" x-text="template.tag"></span>
                        </div>
                        <p class="text-sm text-gray-400 mb-3" x-text="template.desc"></p>

                        <template x-if="selectedTemplate === index">
                            <div class="space-y-3 mt-4 pt-4 border-t border-surface-500">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">动作类型</label>
                                    <input type="text" x-model="promptParams.action" placeholder="如：深蹲、硬拉、卧推"
                                        class="w-full bg-surface-700 border border-surface-500 rounded px-3 py-2 text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">训练目标</label>
                                    <input type="text" x-model="promptParams.goal" placeholder="如：力量、增肌、康复"
                                        class="w-full bg-surface-700 border border-surface-500 rounded px-3 py-2 text-sm">
                                </div>
                                <div class="grid grid-cols-2 gap-2">
                                    <div>
                                        <label class="block text-xs text-gray-400 mb-1">负重</label>
                                        <input type="text" x-model="promptParams.weight" placeholder="如：60kg"
                                            class="w-full bg-surface-700 border border-surface-500 rounded px-3 py-2 text-sm">
                                    </div>
                                    <div>
                                        <label class="block text-xs text-gray-400 mb-1">视角</label>
                                        <select x-model="promptParams.angle"
                                            class="w-full bg-surface-700 border border-surface-500 rounded px-3 py-2 text-sm">
                                            <option value="side">侧面</option>
                                            <option value="front">正面</option>
                                            <option value="back">背面</option>
                                            <option value="45deg">45度角</option>
                                        </select>
                                    </div>
                                </div>
                                <button @click="copyPrompt(template)"
                                    class="btn-primary w-full text-sm flex items-center justify-center gap-2">
                                    <i data-lucide="copy" class="w-4 h-4"></i>
                                    复制 Prompt
                                </button>
                            </div>
                        </template>
                    </div>
                </template>
            </div>

            <!-- JSON Schema -->
            <div class="border-t border-surface-600">
                <button @click="showSchema = !showSchema"
                    class="w-full p-4 flex items-center justify-between text-sm text-gray-400 hover:text-white transition">
                    <span class="flex items-center gap-2">
                        <i data-lucide="code" class="w-4 h-4"></i>
                        输出 JSON Schema
                    </span>
                    <i data-lucide="chevron-down" class="w-4 h-4 transition-transform"
                        :class="{ 'rotate-180': showSchema }"></i>
                </button>
                <template x-if="showSchema">
                    <div class="px-4 pb-4">
                        <pre
                            class="text-xs bg-surface-900 p-3 rounded-lg overflow-x-auto font-mono text-gray-300 max-h-48 overflow-y-auto">{
  "subtitle_segments": [{
    "start_ms": 0,
    "end_ms": 2000,
    "text": "准备姿势，核心收紧",
    "tone": "coach",
    "focus": "core",
    "severity": "tip",
    "confidence": 0.95
  }],
  "events": [{
    "t_ms": 1500,
    "type": "rep_start",
    "rep_index": 1,
    "score": 85,
    "metric_scores": {
      "stability": 8,
      "rom": 9,
      "trajectory": 8,
      "tempo": 7,
      "control": 9
    },
    "badge": "完美下蹲!"
  }]
}</pre>
                    </div>
                </template>
            </div>
        </aside>

        <!-- Center: Video Player -->
        <section class="flex-1 flex flex-col bg-surface-900 overflow-hidden">
            <!-- Video Area -->
            <div class="flex-1 flex items-center justify-center p-4" x-ref="videoArea">
                <template x-if="!video.src">
                    <div class="text-center">
                        <label class="cursor-pointer">
                            <div
                                class="w-80 h-48 border-2 border-dashed border-surface-500 rounded-2xl flex flex-col items-center justify-center gap-4 hover:border-accent-primary hover:bg-accent-primary/5 transition-all">
                                <i data-lucide="video" class="w-12 h-12 text-gray-500"></i>
                                <div>
                                    <p class="font-medium">上传训练视频</p>
                                    <p class="text-sm text-gray-400 mt-1">支持 MP4, WebM, MOV 格式</p>
                                </div>
                            </div>
                            <input type="file" accept="video/*" class="hidden" @change="handleVideoUpload($event)">
                        </label>
                    </div>
                </template>

                <template x-if="video.src">
                    <div class="w-full max-w-4xl">
                        <div class="video-container rounded-lg overflow-hidden shadow-2xl" x-ref="videoContainer">
                            <video x-ref="videoEl" :src="video.src" @loadedmetadata="onVideoLoaded()"
                                @timeupdate="onTimeUpdate()" @ended="isPlaying = false" class="w-full"></video>

                            <!-- Subtitle Overlay -->
                            <div class="subtitle-overlay" x-show="currentSubtitle && renderSettings.showSubtitles">
                                <div class="subtitle-text" :class="currentSubtitle?.severity"
                                    x-text="currentSubtitle?.text"></div>
                            </div>

                            <!-- HUD Overlay -->
                            <div class="hud-overlay" x-show="renderSettings.showHUD && currentScore !== null">
                                <div class="hud-score" x-text="currentScore"></div>
                                <div class="text-sm text-gray-300 font-mono">/ 100</div>
                                <template x-if="currentBadge">
                                    <div class="hud-badge" x-text="currentBadge"></div>
                                </template>
                            </div>
                        </div>

                        <!-- Video Controls -->
                        <div class="mt-4 flex items-center gap-4">
                            <button @click="togglePlay()"
                                class="w-12 h-12 rounded-full bg-accent-primary text-surface-900 flex items-center justify-center hover:scale-105 transition-transform">
                                <i :data-lucide="isPlaying ? 'pause' : 'play'" class="w-5 h-5"></i>
                            </button>

                            <div class="flex-1">
                                <input type="range" min="0" :max="video.duration" step="0.01" :value="video.currentTime"
                                    @input="seekVideo($event.target.value)">
                            </div>

                            <div class="font-mono text-sm text-gray-400 w-32 text-right">
                                <span x-text="formatTime(video.currentTime)"></span>
                                <span class="text-gray-600">/</span>
                                <span x-text="formatTime(video.duration)"></span>
                            </div>
                        </div>

                        <!-- Video Info -->
                        <div class="mt-3 flex items-center gap-4 text-xs text-gray-500">
                            <span class="flex items-center gap-1">
                                <i data-lucide="monitor" class="w-3 h-3"></i>
                                <span x-text="`${video.width}×${video.height}`"></span>
                            </span>
                            <span class="flex items-center gap-1">
                                <i data-lucide="clock" class="w-3 h-3"></i>
                                <span x-text="`${video.fps} fps`"></span>
                            </span>
                            <span class="flex items-center gap-1">
                                <i data-lucide="hard-drive" class="w-3 h-3"></i>
                                <span x-text="formatFileSize(video.size)"></span>
                            </span>
                        </div>

                        <!-- Timeline -->
                        <div class="timeline-container mt-4 rounded-lg overflow-hidden" x-show="analysis">
                            <div class="timeline-track">
                                <template x-for="(seg, i) in analysis?.subtitle_segments || []" :key="i">
                                    <div class="timeline-segment"
                                        :style="`left: ${seg.start_ms / video.duration / 10}%; width: ${(seg.end_ms - seg.start_ms) / video.duration / 10}%`"
                                        :class="seg.severity === 'warn' ? 'bg-accent-warn/60' : seg.severity === 'praise' ? 'bg-accent-primary/60' : 'bg-accent-secondary/60'"
                                        @click="seekVideo(seg.start_ms / 1000)" :title="seg.text"></div>
                                </template>
                            </div>
                            <div class="timeline-playhead"
                                :style="`left: ${(video.currentTime / video.duration) * 100}%`"></div>
                        </div>
                    </div>
                </template>
            </div>
        </section>

        <!-- Right Panel: Results & Calibration -->
        <aside class="w-96 bg-surface-800 border-l border-surface-600 flex flex-col overflow-hidden">
            <!-- Tabs -->
            <div class="flex border-b border-surface-600">
                <button @click="rightTab = 'import'" class="flex-1 py-3 text-sm font-medium transition"
                    :class="rightTab === 'import' ? 'text-accent-primary border-b-2 border-accent-primary' : 'text-gray-400 hover:text-white'">
                    JSON 导入
                </button>
                <button @click="rightTab = 'calibrate'" class="flex-1 py-3 text-sm font-medium transition"
                    :class="rightTab === 'calibrate' ? 'text-accent-primary border-b-2 border-accent-primary' : 'text-gray-400 hover:text-white'">
                    偏移校准
                </button>
                <button @click="rightTab = 'segments'" class="flex-1 py-3 text-sm font-medium transition"
                    :class="rightTab === 'segments' ? 'text-accent-primary border-b-2 border-accent-primary' : 'text-gray-400 hover:text-white'">
                    字幕列表
                </button>
            </div>

            <!-- Import Tab -->
            <div x-show="rightTab === 'import'" class="flex-1 flex flex-col overflow-hidden">
                <div class="p-4 flex-1 flex flex-col">
                    <label class="block text-sm text-gray-400 mb-2">粘贴 LLM 输出的 JSON</label>
                    <textarea x-model="jsonInput" placeholder='{ "subtitle_segments": [...], "events": [...] }'
                        class="flex-1 w-full bg-surface-700 border border-surface-500 rounded-lg p-3 text-sm font-mono resize-none focus:border-accent-primary focus:outline-none"></textarea>

                    <button @click="parseJSON()" class="btn-primary w-full mt-4 flex items-center justify-center gap-2">
                        <i data-lucide="check-circle" class="w-4 h-4"></i>
                        解析导入
                    </button>
                </div>

                <!-- Validation Errors -->
                <template x-if="validationErrors.length > 0">
                    <div class="border-t border-surface-600 p-4">
                        <h4 class="text-sm font-medium text-accent-error flex items-center gap-2 mb-3">
                            <i data-lucide="alert-circle" class="w-4 h-4"></i>
                            校验错误
                        </h4>
                        <div class="space-y-2 max-h-40 overflow-y-auto">
                            <template x-for="(err, i) in validationErrors" :key="i">
                                <div class="text-xs p-2 bg-accent-error/10 border border-accent-error/30 rounded cursor-pointer hover:bg-accent-error/20"
                                    @click="err.time !== undefined && seekVideo(err.time / 1000)">
                                    <span x-text="err.message"></span>
                                    <template x-if="err.time !== undefined">
                                        <span class="text-gray-400 ml-2"
                                            x-text="`@ ${formatTime(err.time / 1000)}`"></span>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>
            </div>

            <!-- Calibration Tab -->
            <div x-show="rightTab === 'calibrate'" class="flex-1 overflow-y-auto p-4">
                <div class="space-y-6">
                    <!-- Global Offset -->
                    <div>
                        <h4 class="text-sm font-medium mb-3 flex items-center gap-2">
                            <i data-lucide="move-horizontal" class="w-4 h-4 text-accent-primary"></i>
                            全局偏移
                        </h4>
                        <div class="bg-surface-700 rounded-lg p-4">
                            <div class="text-center mb-4">
                                <span class="text-3xl font-mono font-bold"
                                    :class="calibration.globalOffset >= 0 ? 'text-accent-primary' : 'text-accent-error'"
                                    x-text="`${calibration.globalOffset >= 0 ? '+' : ''}${calibration.globalOffset} ms`"></span>
                            </div>

                            <input type="range" min="-5000" max="5000" step="10"
                                x-model.number="calibration.globalOffset">

                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>-5s</span>
                                <span>0</span>
                                <span>+5s</span>
                            </div>

                            <div class="grid grid-cols-4 gap-2 mt-4">
                                <button @click="calibration.globalOffset -= 200"
                                    class="btn-secondary text-xs py-2">-200</button>
                                <button @click="calibration.globalOffset -= 50"
                                    class="btn-secondary text-xs py-2">-50</button>
                                <button @click="calibration.globalOffset += 50"
                                    class="btn-secondary text-xs py-2">+50</button>
                                <button @click="calibration.globalOffset += 200"
                                    class="btn-secondary text-xs py-2">+200</button>
                            </div>

                            <button @click="calibration.globalOffset = 0" class="btn-secondary w-full mt-3 text-sm">
                                重置为 0
                            </button>
                        </div>
                    </div>

                    <!-- Quick Align -->
                    <div>
                        <h4 class="text-sm font-medium mb-3 flex items-center gap-2">
                            <i data-lucide="crosshair" class="w-4 h-4 text-accent-secondary"></i>
                            一键对齐
                        </h4>
                        <div class="bg-surface-700 rounded-lg p-4">
                            <p class="text-sm text-gray-400 mb-3">选择一条字幕，将其对齐到当前播放位置</p>

                            <select x-model.number="alignSegmentIndex"
                                class="w-full bg-surface-600 border border-surface-500 rounded-lg px-3 py-2 text-sm mb-3">
                                <option value="-1">选择字幕片段...</option>
                                <template x-for="(seg, i) in analysis?.subtitle_segments || []" :key="i">
                                    <option :value="i"
                                        x-text="`${formatTime(seg.start_ms / 1000)} - ${seg.text.substring(0, 20)}...`">
                                    </option>
                                </template>
                            </select>

                            <button @click="alignToCurrentTime()" class="btn-primary w-full text-sm"
                                :disabled="alignSegmentIndex < 0">
                                对齐到当前时间
                            </button>
                        </div>
                    </div>

                    <!-- Render Settings -->
                    <div>
                        <h4 class="text-sm font-medium mb-3 flex items-center gap-2">
                            <i data-lucide="settings" class="w-4 h-4 text-accent-warn"></i>
                            渲染设置
                        </h4>
                        <div class="space-y-3">
                            <label
                                class="flex items-center justify-between p-3 bg-surface-700 rounded-lg cursor-pointer">
                                <span class="text-sm">显示字幕</span>
                                <input type="checkbox" x-model="renderSettings.showSubtitles"
                                    class="w-5 h-5 rounded bg-surface-600">
                            </label>
                            <label
                                class="flex items-center justify-between p-3 bg-surface-700 rounded-lg cursor-pointer">
                                <span class="text-sm">显示 HUD</span>
                                <input type="checkbox" x-model="renderSettings.showHUD"
                                    class="w-5 h-5 rounded bg-surface-600">
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Segments Tab -->
            <div x-show="rightTab === 'segments'" class="flex-1 overflow-y-auto p-4">
                <template x-if="!analysis">
                    <div class="text-center text-gray-500 py-8">
                        <i data-lucide="list" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                        <p class="text-sm">导入 JSON 后显示字幕列表</p>
                    </div>
                </template>

                <template x-if="analysis">
                    <div class="space-y-2">
                        <div class="flex items-center justify-between mb-4">
                            <span class="text-sm text-gray-400"
                                x-text="`共 ${analysis.subtitle_segments.length} 条字幕`"></span>
                            <button @click="sparseSubtitles()" class="text-xs text-accent-secondary hover:underline">
                                一键稀疏化
                            </button>
                        </div>

                        <template x-for="(seg, i) in analysis.subtitle_segments" :key="i">
                            <div class="segment-item"
                                :class="{ 'active': currentSubtitleIndex === i, 'disabled': seg.disabled }"
                                @click="seekVideo((seg.start_ms + calibration.globalOffset) / 1000)">
                                <div class="flex items-start justify-between gap-2">
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center gap-2 mb-1">
                                            <span class="text-xs font-mono text-gray-500"
                                                x-text="formatTime(seg.start_ms / 1000)"></span>
                                            <span class="text-xs px-1.5 py-0.5 rounded" :class="seg.severity === 'warn' ? 'bg-accent-warn/20 text-accent-warn' : 
                                                          seg.severity === 'praise' ? 'bg-accent-primary/20 text-accent-primary' : 
                                                          'bg-accent-secondary/20 text-accent-secondary'"
                                                x-text="seg.severity"></span>
                                            <template x-if="seg.confidence < 0.8">
                                                <span class="text-xs text-gray-500">(低置信度)</span>
                                            </template>
                                        </div>
                                        <p class="text-sm truncate" x-text="seg.text"></p>
                                    </div>
                                    <button @click.stop="seg.disabled = !seg.disabled"
                                        class="p-1 hover:bg-surface-600 rounded">
                                        <i :data-lucide="seg.disabled ? 'eye-off' : 'eye'"
                                            class="w-4 h-4 text-gray-400"></i>
                                    </button>
                                </div>
                            </div>
                        </template>
                    </div>
                </template>
            </div>
        </aside>
    </main>

    <!-- Hidden Canvas for Export -->
    <canvas x-ref="exportCanvas" class="hidden"></canvas>

    <script>
        // FFmpeg instance stored outside Alpine reactive system to avoid proxy conflicts
        let _ffmpegInstance = null;

        function app() {
            return {
                // State
                video: {
                    src: null,
                    duration: 0,
                    currentTime: 0,
                    width: 0,
                    height: 0,
                    fps: 30,
                    size: 0,
                    file: null
                },
                isPlaying: false,
                analysis: null,
                projectStatus: 'empty',

                // UI State
                rightTab: 'import',
                selectedTemplate: 0,
                showSchema: false,
                jsonInput: '',
                validationErrors: [],
                alignSegmentIndex: -1,

                // Toast
                toast: { show: false, message: '', type: 'success' },

                // Export
                showExportModal: false,
                isExporting: false,
                exportProgress: { current: 0, total: 0 },
                exportSettings: {
                    quality: 'high',
                    includeHUD: true,
                    includeSubtitles: true
                },

                // Calibration
                calibration: {
                    globalOffset: 0
                },

                // Render Settings
                renderSettings: {
                    showSubtitles: true,
                    showHUD: true
                },

                // FFmpeg Compression
                ffmpegLoaded: false,
                showCompressModal: false,
                isCompressing: false,
                compressSettings: {
                    quality: 'medium',
                    resolution: 'original',
                    fps: 'original',
                    startTime: 0,
                    endTime: 0
                },
                compressProgress: {
                    stage: '',
                    message: '',
                    percent: 0
                },

                // Current subtitle/score for overlay
                currentSubtitle: null,
                currentSubtitleIndex: -1,
                currentScore: null,
                currentBadge: null,

                // Prompt
                promptParams: {
                    action: '',
                    goal: '',
                    weight: '',
                    angle: 'side'
                },

                promptTemplates: [
                    {
                        name: '口令教练',
                        tag: '高频短句',
                        style: 'coach',
                        desc: '每1.5-3秒一条短促口令，节奏感强，覆盖率高',
                        prompt: (p) => `你是一位专业的健身教练，正在观看一段${p.action || '力量训练'}视频（${p.angle === 'side' ? '侧面' : p.angle === 'front' ? '正面' : p.angle === 'back' ? '背面' : '45度角'}视角${p.weight ? '，负重' + p.weight : ''}）。

请以教练口令风格，为这段视频生成密集的实时解说字幕。

要求：
1. 每1.5-3秒输出一条简短口令（2-8个字）
2. 口令要有节奏感，像真实教练在旁边指导
3. 覆盖动作的每个关键相位
4. 发现问题时立即给出纠正提示
5. 训练目标：${p.goal || '标准动作'}

请严格按以下JSON格式输出（不要添加任何其他文字）：
${JSON.stringify({
                            subtitle_segments: [{
                                start_ms: "number - 开始时间毫秒",
                                end_ms: "number - 结束时间毫秒",
                                text: "string - 口令文字",
                                tone: "coach",
                                focus: "string - 关注点如core/knee/bar等",
                                severity: "praise/tip/warn",
                                confidence: "number 0-1"
                            }],
                            events: [{
                                t_ms: "number - 事件时间",
                                type: "rep_start/rep_end/error/praise",
                                rep_index: "number",
                                score: "number 0-100",
                                metric_scores: { stability: 8, rom: 9, trajectory: 8, tempo: 7, control: 9 },
                                badge: "string - 短标签"
                            }]
                        }, null, 2)}`
                    },
                    {
                        name: '教学解释',
                        tag: '少而精',
                        style: 'teach',
                        desc: '每个rep给1-2条深度解释，说明为什么和怎么做',
                        prompt: (p) => `你是一位健身教学专家，正在分析一段${p.action || '力量训练'}视频（${p.angle === 'side' ? '侧面' : p.angle === 'front' ? '正面' : p.angle === 'back' ? '背面' : '45度角'}视角${p.weight ? '，负重' + p.weight : ''}）。

请以教学解释风格，为视频中每个动作的关键相位生成深度解说。

要求：
1. 每个rep只在关键点给出1-2条解释
2. 内容包含"为什么这样做"和"如何改进"
3. 使用专业但易懂的语言
4. 训练目标：${p.goal || '技术提升'}

请严格按以下JSON格式输出：
${JSON.stringify({
                            subtitle_segments: [{
                                start_ms: "number",
                                end_ms: "number",
                                text: "string - 教学解释",
                                tone: "teach",
                                focus: "string",
                                severity: "praise/tip/warn",
                                confidence: "number 0-1"
                            }],
                            events: [{
                                t_ms: "number",
                                type: "rep_start/rep_end/error/praise",
                                rep_index: "number",
                                score: "number 0-100",
                                metric_scores: { stability: 8, rom: 9, trajectory: 8, tempo: 7, control: 9 },
                                badge: "string"
                            }]
                        }, null, 2)}`
                    },
                    {
                        name: '打分挑战',
                        tag: '游戏化',
                        style: 'score',
                        desc: '每rep出分+错误点位+成就徽章，激发训练动力',
                        prompt: (p) => `你是一位游戏化健身教练，正在评判一段${p.action || '力量训练'}视频（${p.angle === 'side' ? '侧面' : p.angle === 'front' ? '正面' : p.angle === 'back' ? '背面' : '45度角'}视角${p.weight ? '，负重' + p.weight : ''}）。

请以打分挑战风格，为每个rep进行评分和点评。

要求：
1. 每个rep结束时给出总分(0-100)和各维度评分
2. 发现错误时标记具体时间点和扣分原因
3. 表现出色时给予成就徽章
4. 字幕简短有力，像游戏提示
5. 训练目标：${p.goal || '挑战高分'}

请严格按以下JSON格式输出：
${JSON.stringify({
                            subtitle_segments: [{
                                start_ms: "number",
                                end_ms: "number",
                                text: "string - 简短评语",
                                tone: "score",
                                focus: "string",
                                severity: "praise/tip/warn",
                                confidence: "number 0-1"
                            }],
                            events: [{
                                t_ms: "number",
                                type: "rep_start/rep_end/error/praise",
                                rep_index: "number",
                                score: "number 0-100",
                                metric_scores: { stability: 8, rom: 9, trajectory: 8, tempo: 7, control: 9 },
                                badge: "string - 如'完美控制!' '稳如磐石!'"
                            }]
                        }, null, 2)}`
                    },
                    {
                        name: '多角色吐槽',
                        tag: '娱乐传播',
                        style: 'roast',
                        desc: '教练/物理老师/毒舌搭子多角色点评，适合分享',
                        prompt: (p) => `你需要扮演三个角色来点评一段${p.action || '力量训练'}视频（${p.angle === 'side' ? '侧面' : p.angle === 'front' ? '正面' : p.angle === 'back' ? '背面' : '45度角'}视角${p.weight ? '，负重' + p.weight : ''}）：

角色1 - 严格教练：专业、直接、偶尔严厉
角色2 - 物理老师：用力学原理解释动作
角色3 - 毒舌搭子：幽默吐槽但有建设性

要求：
1. 每个关键点让三个角色轮流发言
2. 每条字幕标注是哪个角色
3. 保持幽默但不失专业性
4. 适合社交媒体传播

请严格按以下JSON格式输出：
${JSON.stringify({
                            subtitle_segments: [{
                                start_ms: "number",
                                end_ms: "number",
                                text: "string - [角色名]: 台词",
                                tone: "roast",
                                focus: "string",
                                severity: "praise/tip/warn",
                                confidence: "number 0-1"
                            }],
                            events: [{
                                t_ms: "number",
                                type: "rep_start/rep_end/error/praise",
                                rep_index: "number",
                                score: "number 0-100",
                                metric_scores: { stability: 8, rom: 9, trajectory: 8, tempo: 7, control: 9 },
                                badge: "string"
                            }]
                        }, null, 2)}`
                    }
                ],

                // Methods
                init() {
                    this.$nextTick(() => {
                        lucide.createIcons();
                    });

                    // Watch for icon updates
                    this.$watch('rightTab', () => this.$nextTick(() => lucide.createIcons()));
                    this.$watch('showExportModal', () => this.$nextTick(() => lucide.createIcons()));
                    this.$watch('isPlaying', () => this.$nextTick(() => lucide.createIcons()));
                    this.$watch('analysis', () => this.$nextTick(() => lucide.createIcons()));
                },

                showToast(message, type = 'success') {
                    this.toast = { show: true, message, type };
                },

                handleVideoUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    this.video.file = file;
                    this.video.src = URL.createObjectURL(file);
                    this.video.size = file.size;
                },

                onVideoLoaded() {
                    const v = this.$refs.videoEl;
                    this.video.duration = v.duration;
                    this.video.width = v.videoWidth;
                    this.video.height = v.videoHeight;

                    // Estimate FPS (default to 30 if can't detect)
                    this.video.fps = 30;

                    this.showToast('视频加载成功');
                    this.$nextTick(() => lucide.createIcons());
                },

                onTimeUpdate() {
                    const v = this.$refs.videoEl;
                    this.video.currentTime = v.currentTime;

                    // Update current subtitle and score
                    this.updateOverlays();
                },

                updateOverlays() {
                    if (!this.analysis) {
                        this.currentSubtitle = null;
                        this.currentScore = null;
                        this.currentBadge = null;
                        return;
                    }

                    const currentMs = this.video.currentTime * 1000 - this.calibration.globalOffset;

                    // Find current subtitle
                    this.currentSubtitle = null;
                    this.currentSubtitleIndex = -1;

                    for (let i = 0; i < this.analysis.subtitle_segments.length; i++) {
                        const seg = this.analysis.subtitle_segments[i];
                        if (!seg.disabled && currentMs >= seg.start_ms && currentMs <= seg.end_ms) {
                            this.currentSubtitle = seg;
                            this.currentSubtitleIndex = i;
                            break;
                        }
                    }

                    // Find current score and badge from events
                    let latestScore = null;
                    let latestBadge = null;

                    for (const event of this.analysis.events || []) {
                        const eventTime = event.t_ms || event.start_ms || 0;
                        if (eventTime <= currentMs) {
                            if (event.score !== undefined) latestScore = event.score;
                            if (event.badge && currentMs - eventTime < 2000) {
                                latestBadge = event.badge;
                            }
                        }
                    }

                    this.currentScore = latestScore;
                    this.currentBadge = latestBadge;
                },

                togglePlay() {
                    const v = this.$refs.videoEl;
                    if (this.isPlaying) {
                        v.pause();
                    } else {
                        v.play();
                    }
                    this.isPlaying = !this.isPlaying;
                },

                seekVideo(time) {
                    const v = this.$refs.videoEl;
                    v.currentTime = parseFloat(time);
                    this.video.currentTime = parseFloat(time);
                    this.updateOverlays();
                },

                formatTime(seconds) {
                    if (!seconds || isNaN(seconds)) return '0:00';
                    const m = Math.floor(seconds / 60);
                    const s = Math.floor(seconds % 60);
                    return `${m}:${s.toString().padStart(2, '0')}`;
                },

                formatFileSize(bytes) {
                    if (!bytes) return '0 B';
                    const units = ['B', 'KB', 'MB', 'GB'];
                    let i = 0;
                    while (bytes >= 1024 && i < units.length - 1) {
                        bytes /= 1024;
                        i++;
                    }
                    return `${bytes.toFixed(1)} ${units[i]}`;
                },

                copyPrompt(template) {
                    const prompt = template.prompt(this.promptParams);
                    navigator.clipboard.writeText(prompt).then(() => {
                        this.showToast('Prompt 已复制到剪贴板');
                    });
                },

                parseJSON() {
                    this.validationErrors = [];

                    try {
                        const data = JSON.parse(this.jsonInput);

                        // Validate structure
                        if (!data.subtitle_segments || !Array.isArray(data.subtitle_segments)) {
                            this.validationErrors.push({ message: '缺少 subtitle_segments 数组' });
                            return;
                        }

                        const durationMs = this.video.duration * 1000;

                        // Validate each segment
                        data.subtitle_segments.forEach((seg, i) => {
                            if (seg.start_ms === undefined || seg.end_ms === undefined) {
                                this.validationErrors.push({ message: `片段 ${i + 1}: 缺少时间戳` });
                            }
                            if (seg.start_ms >= seg.end_ms) {
                                this.validationErrors.push({ message: `片段 ${i + 1}: start_ms >= end_ms`, time: seg.start_ms });
                            }
                            if (seg.end_ms > durationMs && durationMs > 0) {
                                this.validationErrors.push({ message: `片段 ${i + 1}: 超出视频时长`, time: seg.start_ms });
                            }
                            if (!seg.text) {
                                this.validationErrors.push({ message: `片段 ${i + 1}: 缺少文本` });
                            }

                            // Add disabled field
                            seg.disabled = false;
                        });

                        // Check for overlaps
                        const sorted = [...data.subtitle_segments].sort((a, b) => a.start_ms - b.start_ms);
                        for (let i = 1; i < sorted.length; i++) {
                            if (sorted[i].start_ms < sorted[i - 1].end_ms) {
                                this.validationErrors.push({
                                    message: `片段重叠: ${i} 和 ${i + 1}`,
                                    time: sorted[i].start_ms
                                });
                            }
                        }

                        // Check density
                        if (data.subtitle_segments.length > durationMs / 1000) {
                            this.validationErrors.push({ message: '字幕密度过高，建议稀疏化' });
                        }

                        if (this.validationErrors.length === 0) {
                            this.analysis = data;
                            this.projectStatus = 'imported';
                            this.rightTab = 'segments';
                            this.showToast(`成功导入 ${data.subtitle_segments.length} 条字幕`);
                        }

                    } catch (e) {
                        this.validationErrors.push({ message: 'JSON 解析失败: ' + e.message });
                    }
                },

                alignToCurrentTime() {
                    if (this.alignSegmentIndex < 0 || !this.analysis) return;

                    const seg = this.analysis.subtitle_segments[this.alignSegmentIndex];
                    const currentMs = this.video.currentTime * 1000;
                    const offset = currentMs - seg.start_ms;

                    this.calibration.globalOffset = Math.round(offset);
                    this.projectStatus = 'calibrated';
                    this.showToast(`已对齐，偏移量: ${this.calibration.globalOffset}ms`);
                },

                sparseSubtitles() {
                    if (!this.analysis) return;

                    // Simple sparsification: keep every other segment
                    this.analysis.subtitle_segments.forEach((seg, i) => {
                        seg.disabled = i % 2 === 1;
                    });

                    const enabled = this.analysis.subtitle_segments.filter(s => !s.disabled).length;
                    this.showToast(`已稀疏化，保留 ${enabled} 条字幕`);
                },

                importJSON() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                this.jsonInput = event.target.result;
                                this.rightTab = 'import';
                            };
                            reader.readAsText(file);
                        }
                    };
                    input.click();
                },

                exportJSON() {
                    if (!this.analysis) return;

                    const data = {
                        ...this.analysis,
                        calibration: this.calibration
                    };

                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'fitcoach-analysis.json';
                    a.click();
                    URL.revokeObjectURL(url);

                    this.showToast('JSON 导出成功');
                },

                async startExport() {
                    if (!this.video.src || !this.analysis) return;

                    this.isExporting = true;
                    const video = this.$refs.videoEl;
                    const canvas = this.$refs.exportCanvas;
                    const ctx = canvas.getContext('2d');

                    // Set canvas size to match video
                    canvas.width = this.video.width;
                    canvas.height = this.video.height;

                    // Calculate bitrate based on quality
                    const bitrates = {
                        medium: 4000000,
                        high: 8000000,
                        ultra: 15000000
                    };
                    const bitrate = bitrates[this.exportSettings.quality] || 8000000;

                    // Check codec support
                    let mimeType = 'video/webm;codecs=vp9,opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'video/webm;codecs=vp8,opus';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'video/webm';
                        }
                    }

                    // Create stream from canvas
                    const stream = canvas.captureStream(this.video.fps);

                    // Add audio track if available
                    if (video.captureStream) {
                        const videoStream = video.captureStream();
                        const audioTrack = videoStream.getAudioTracks()[0];
                        if (audioTrack) {
                            stream.addTrack(audioTrack);
                        }
                    }

                    // Setup recorder
                    const recorder = new MediaRecorder(stream, {
                        mimeType,
                        videoBitsPerSecond: bitrate
                    });

                    const chunks = [];
                    recorder.ondataavailable = (e) => chunks.push(e.data);

                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'fitcoach-export.webm';
                        a.click();
                        URL.revokeObjectURL(url);

                        this.isExporting = false;
                        this.showExportModal = false;
                        this.showToast('WebM 导出成功');
                    };

                    // Calculate total frames
                    const totalFrames = Math.ceil(this.video.duration * this.video.fps);
                    this.exportProgress.total = totalFrames;
                    this.exportProgress.current = 0;

                    recorder.start();

                    // Render each frame
                    video.currentTime = 0;
                    video.muted = true;

                    const renderFrame = async () => {
                        if (video.currentTime >= this.video.duration) {
                            recorder.stop();
                            video.muted = false;
                            return;
                        }

                        // Draw video frame
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                        // Draw overlays
                        const currentMs = video.currentTime * 1000 - this.calibration.globalOffset;

                        // Draw subtitle
                        if (this.exportSettings.includeSubtitles) {
                            for (const seg of this.analysis.subtitle_segments) {
                                if (!seg.disabled && currentMs >= seg.start_ms && currentMs <= seg.end_ms) {
                                    this.drawSubtitle(ctx, seg, canvas.width, canvas.height);
                                    break;
                                }
                            }
                        }

                        // Draw HUD
                        if (this.exportSettings.includeHUD) {
                            let score = null;
                            let badge = null;

                            for (const event of this.analysis.events || []) {
                                const eventTime = event.t_ms || event.start_ms || 0;
                                if (eventTime <= currentMs) {
                                    if (event.score !== undefined) score = event.score;
                                    if (event.badge && currentMs - eventTime < 2000) badge = event.badge;
                                }
                            }

                            if (score !== null) {
                                this.drawHUD(ctx, score, badge, canvas.width, canvas.height);
                            }
                        }

                        this.exportProgress.current++;

                        // Next frame
                        video.currentTime += 1 / this.video.fps;

                        await new Promise(resolve => {
                            video.onseeked = () => {
                                requestAnimationFrame(() => {
                                    renderFrame();
                                    resolve();
                                });
                            };
                        });
                    };

                    video.onseeked = () => renderFrame();
                    video.currentTime = 0;
                },

                drawSubtitle(ctx, seg, width, height) {
                    const text = seg.text;
                    const fontSize = Math.max(24, height / 20);

                    ctx.font = `600 ${fontSize}px Outfit, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const textWidth = ctx.measureText(text).width;
                    const padding = 20;
                    const boxWidth = textWidth + padding * 2;
                    const boxHeight = fontSize + padding;
                    const x = width / 2;
                    const y = height * 0.88;

                    // Background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    ctx.beginPath();
                    ctx.roundRect(x - boxWidth / 2, y - boxHeight / 2, boxWidth, boxHeight, 8);
                    ctx.fill();

                    // Severity indicator
                    if (seg.severity) {
                        const colors = { warn: '#ffaa00', praise: '#00ff88', tip: '#00d4ff' };
                        ctx.fillStyle = colors[seg.severity] || '#00d4ff';
                        ctx.fillRect(x - boxWidth / 2, y - boxHeight / 2, 4, boxHeight);
                    }

                    // Text
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.fillText(text, x, y);
                    ctx.shadowBlur = 0;
                },

                drawHUD(ctx, score, badge, width, height) {
                    const fontSize = Math.max(40, height / 12);
                    const x = width - 20;
                    const y = 20;

                    // Score
                    ctx.font = `700 ${fontSize}px JetBrains Mono, monospace`;
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = 'rgba(0, 255, 136, 0.5)';
                    ctx.shadowBlur = 20;
                    ctx.fillText(score.toString(), x, y);
                    ctx.shadowBlur = 0;

                    // /100
                    ctx.font = `500 ${fontSize / 3}px JetBrains Mono, monospace`;
                    ctx.fillStyle = '#aaaaaa';
                    ctx.fillText('/ 100', x, y + fontSize);

                    // Badge
                    if (badge) {
                        ctx.font = `600 ${fontSize / 3}px Outfit, sans-serif`;
                        const badgeY = y + fontSize + fontSize / 2 + 10;
                        const badgeWidth = ctx.measureText(badge).width + 24;

                        ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
                        ctx.strokeStyle = '#00ff88';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.roundRect(x - badgeWidth, badgeY, badgeWidth, fontSize / 2.5 + 10, 20);
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#00ff88';
                        ctx.textAlign = 'right';
                        ctx.fillText(badge, x - 12, badgeY + fontSize / 5 + 5);
                    }
                },

                // FFmpeg Compression Methods
                async loadFFmpeg() {
                    if (this.ffmpegLoaded) return;

                    try {
                        const { FFmpeg } = FFmpegWASM;
                        const { toBlobURL } = FFmpegUtil;

                        _ffmpegInstance = new FFmpeg();

                        const self = this;
                        _ffmpegInstance.on('log', ({ message }) => {
                            console.log('[FFmpeg]', message);
                        });

                        _ffmpegInstance.on('progress', ({ progress, time }) => {
                            self.compressProgress.percent = Math.min(progress * 100, 99);
                            self.compressProgress.message = `处理时间: ${(time / 1000000).toFixed(1)}s`;
                        });

                        const ffmpegBaseURL = 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm';
                        const coreBaseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm';

                        self.compressProgress.stage = '下载 Worker 脚本...';
                        self.compressProgress.percent = 5;
                        self.compressProgress.message = '首次加载需要下载约 32MB，请耐心等待...';

                        // Worker script must also be converted to blob URL
                        const workerURL = await toBlobURL(`${ffmpegBaseURL}/worker.js`, 'text/javascript');

                        self.compressProgress.stage = '下载 FFmpeg 核心模块...';
                        self.compressProgress.percent = 15;
                        const coreURL = await toBlobURL(`${coreBaseURL}/ffmpeg-core.js`, 'text/javascript');

                        self.compressProgress.stage = '下载 WebAssembly 模块 (~30MB)...';
                        self.compressProgress.percent = 30;
                        const wasmURL = await toBlobURL(`${coreBaseURL}/ffmpeg-core.wasm`, 'application/wasm');

                        self.compressProgress.stage = '初始化 FFmpeg 引擎...';
                        self.compressProgress.percent = 80;

                        // Load FFmpeg with all blob URLs
                        await _ffmpegInstance.load({
                            classWorkerURL: workerURL,
                            coreURL,
                            wasmURL
                        });

                        this.ffmpegLoaded = true;
                        self.compressProgress.percent = 100;
                        self.compressProgress.stage = '就绪';
                        this.$nextTick(() => lucide.createIcons());
                    } catch (error) {
                        console.error('Failed to load FFmpeg:', error);
                        this.showToast('FFmpeg 加载失败: ' + error.message, 'error');
                    }
                },

                async openCompressModal() {
                    this.showCompressModal = true;
                    this.compressSettings.startTime = 0;
                    this.compressSettings.endTime = this.video.duration;
                    this.$nextTick(() => lucide.createIcons());

                    // Start loading FFmpeg in background
                    if (!this.ffmpegLoaded) {
                        this.loadFFmpeg();
                    }
                },

                estimateCompressedSize() {
                    if (!this.video.size) return '计算中...';

                    const qualityFactors = {
                        'high': 0.2,
                        'medium': 0.1,
                        'low': 0.05,
                        'ultra-low': 0.033
                    };

                    const resolutionFactors = {
                        'original': 1,
                        '720': this.video.height > 720 ? (720 / this.video.height) ** 2 : 1,
                        '480': this.video.height > 480 ? (480 / this.video.height) ** 2 : 1,
                        '360': this.video.height > 360 ? (360 / this.video.height) ** 2 : 1
                    };

                    const fpsFactors = {
                        'original': 1,
                        '24': Math.min(24 / this.video.fps, 1),
                        '15': Math.min(15 / this.video.fps, 1),
                        '10': Math.min(10 / this.video.fps, 1)
                    };

                    const duration = (this.compressSettings.endTime || this.video.duration) - (this.compressSettings.startTime || 0);
                    const durationFactor = duration / this.video.duration;

                    const estimatedSize = this.video.size
                        * qualityFactors[this.compressSettings.quality]
                        * resolutionFactors[this.compressSettings.resolution]
                        * fpsFactors[this.compressSettings.fps]
                        * durationFactor;

                    return this.formatFileSize(Math.max(estimatedSize, 1024));
                },

                estimateCompressionRatio() {
                    if (!this.video.size) return '计算中...';

                    const qualityFactors = {
                        'high': 0.2,
                        'medium': 0.1,
                        'low': 0.05,
                        'ultra-low': 0.033
                    };

                    const resolutionFactors = {
                        'original': 1,
                        '720': this.video.height > 720 ? (720 / this.video.height) ** 2 : 1,
                        '480': this.video.height > 480 ? (480 / this.video.height) ** 2 : 1,
                        '360': this.video.height > 360 ? (360 / this.video.height) ** 2 : 1
                    };

                    const fpsFactors = {
                        'original': 1,
                        '24': Math.min(24 / this.video.fps, 1),
                        '15': Math.min(15 / this.video.fps, 1),
                        '10': Math.min(10 / this.video.fps, 1)
                    };

                    const ratio = 1 / (qualityFactors[this.compressSettings.quality]
                        * resolutionFactors[this.compressSettings.resolution]
                        * fpsFactors[this.compressSettings.fps]);

                    return `约 1/${Math.round(ratio)}`;
                },

                async startCompression() {
                    if (!this.ffmpegLoaded || !this.video.file) {
                        this.showToast('请先等待 FFmpeg 加载完成', 'error');
                        return;
                    }

                    this.isCompressing = true;
                    this.compressProgress = { stage: '准备文件...', message: '', percent: 0 };
                    this.$nextTick(() => lucide.createIcons());

                    try {
                        const { fetchFile } = FFmpegUtil;

                        // Write input file to FFmpeg virtual filesystem
                        this.compressProgress.stage = '加载视频文件...';
                        const inputData = await fetchFile(this.video.file);
                        await _ffmpegInstance.writeFile('input.mp4', inputData);

                        // Build FFmpeg command arguments
                        const args = ['-i', 'input.mp4'];

                        // Time trimming
                        const startTime = parseFloat(this.compressSettings.startTime) || 0;
                        const endTime = parseFloat(this.compressSettings.endTime) || this.video.duration;

                        if (startTime > 0) {
                            args.push('-ss', startTime.toString());
                        }
                        if (endTime < this.video.duration) {
                            args.push('-t', (endTime - startTime).toString());
                        }

                        // Resolution scaling
                        let scaleFilter = '';
                        if (this.compressSettings.resolution !== 'original') {
                            const targetHeight = parseInt(this.compressSettings.resolution);
                            scaleFilter = `scale=-1:${targetHeight}`;
                        }

                        // FPS filter
                        let fpsFilter = '';
                        if (this.compressSettings.fps !== 'original') {
                            fpsFilter = `fps=${this.compressSettings.fps}`;
                        }

                        // Combine filters
                        const filters = [scaleFilter, fpsFilter].filter(f => f).join(',');
                        if (filters) {
                            args.push('-vf', filters);
                        }

                        // Quality settings for WebP
                        const qualityMap = {
                            'high': { q: 75, preset: 'default' },
                            'medium': { q: 50, preset: 'default' },
                            'low': { q: 30, preset: 'picture' },
                            'ultra-low': { q: 15, preset: 'icon' }
                        };

                        const quality = qualityMap[this.compressSettings.quality];

                        // WebP specific options
                        args.push(
                            '-c:v', 'libwebp',
                            '-lossless', '0',
                            '-quality', quality.q.toString(),
                            '-preset', quality.preset,
                            '-compression_level', '6',
                            '-loop', '0',
                            '-an', // Remove audio for WebP
                            '-y',
                            'output.webp'
                        );

                        this.compressProgress.stage = '压缩中...';
                        console.log('FFmpeg command:', args.join(' '));

                        // Execute FFmpeg
                        await _ffmpegInstance.exec(args);

                        // Read output file
                        this.compressProgress.stage = '生成文件...';
                        this.compressProgress.percent = 100;

                        const data = await _ffmpegInstance.readFile('output.webp');

                        // Create download
                        const blob = new Blob([data.buffer], { type: 'image/webp' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'compressed-video.webp';
                        a.click();
                        URL.revokeObjectURL(url);

                        // Cleanup
                        await _ffmpegInstance.deleteFile('input.mp4');
                        await _ffmpegInstance.deleteFile('output.webp');

                        const compressionRatio = (this.video.size / blob.size).toFixed(1);
                        this.showToast(`压缩完成! ${this.formatFileSize(blob.size)} (压缩比 1/${compressionRatio})`);
                        this.showCompressModal = false;

                    } catch (error) {
                        console.error('Compression failed:', error);
                        this.showToast('压缩失败: ' + error.message, 'error');
                    } finally {
                        this.isCompressing = false;
                    }
                }
            };
        }
    </script>
</body>

</html>